{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Quickstart","text":"<p>.nd2 (Nikon NIS Elements) file reader.</p> <p>Features complete metadata retrieval, and many array outputs, including <code>to_dask()</code> and <code>to_xarray()</code> options for lazy and/or annotated arrays (in addition to numpy arrays).</p> <p>This library is thoroughly tested against many nd2 files with the goal of maximizing compatibility and data extraction. (If you find an nd2 file that fails in any way, please open an issue with the file!)</p> <p>Note</p> <p>This library is not affiliated with Nikon in any way, but we are grateful for assistance from the SDK developers at Laboratory Imaging.</p>"},{"location":"#installation","title":"Installation","text":"<p>From pip:</p> <pre><code>pip install nd2\n</code></pre> <p>From conda:</p> <pre><code>conda install -c conda-forge nd2\n</code></pre>"},{"location":"#with-legacy-nd2-file-support","title":"With legacy nd2 file support","text":"<p>Legacy nd2 (JPEG2000) files are also supported, but require <code>imagecodecs</code>.  To install with support for these files use the <code>legacy</code> extra:</p> <pre><code>pip install nd2[legacy]\n</code></pre>"},{"location":"#faster-xml-parsing","title":"Faster XML parsing","text":"<p>Much of the metadata in the file stored as XML.  If found in the environment, <code>nd2</code> will use <code>lxml</code> which is faster than the built-in <code>xml</code> module.  To install with support for <code>lxml</code> use:</p> <pre><code>pip install nd2 lxml\n</code></pre>"},{"location":"#usage-overview","title":"Usage overview","text":"<p>For complete usage details, see the API.</p>"},{"location":"#reading-nd2-files-into-arrays","title":"Reading nd2 files into arrays","text":"<p>To quickly read an nd2 file into a numpy, dask, or xarray array, use <code>nd2.imread()</code>:</p> <pre><code>import nd2\n\n# read to numpy array\nmy_array = nd2.imread('some_file.nd2')\n\n# read to dask array\nmy_array = nd2.imread('some_file.nd2', dask=True)\n\n# read to xarray\nmy_array = nd2.imread('some_file.nd2', xarray=True)\n\n# read file to dask-xarray\nmy_array = nd2.imread('some_file.nd2', xarray=True, dask=True)\n</code></pre>"},{"location":"#extracting-metadata","title":"Extracting metadata","text":"<p>If you want to get metadata, then use the <code>nd2.ND2File</code> class directly:</p> <pre><code>myfile = nd2.ND2File('some_file.nd2')\n</code></pre> <p>Tip</p> <p>It's best to use it as a context manager, so that the file is closed automatically when you're done with it.</p> <pre><code>with nd2.ND2File('some_file.nd2') as myfile:\n    print(myfile.metadata)\n    ...\n</code></pre> <p>The primary metadata is available as attributes on the file object:</p> <p>The key metadata outputs are:</p> <ul> <li><code>ND2File.attributes</code></li> <li><code>ND2File.metadata</code> / <code>ND2File.frame_metadata()</code></li> <li><code>ND2File.experiment</code></li> <li><code>ND2File.text_info</code></li> <li><code>ND2File.events()</code></li> </ul> <p>Other attributes of note include:</p> ATTRIBUTE EXAMPLE OUTPUT <code>myfile.shape</code> <code>(10, 2, 256, 256)</code> <code>myfile.ndim</code> <code>4</code> <code>myfile.dtype</code> <code>np.dtype('uint16')</code> <code>myfile.size</code> <code>1310720</code> (total voxel elements) <code>myfile.sizes</code> <code>{'T': 10, 'C': 2, 'Y': 256, 'X': 256}</code> <code>myfile.voxel_size()</code> <code>VoxelSize(x=0.65, y=0.65, z=1.0)</code> <code>myfile.is_rgb</code> <code>False</code> (whether the file is rgb)"},{"location":"#binary-masks-and-rois","title":"Binary masks and ROIs","text":"<p>Binary masks, if present, can be accessed at <code>ND2File.binary_data</code>.</p> <p>ROIs, if present, can be accessed at <code>ND2File.rois</code>.</p>"},{"location":"#theres-more-in-there","title":"There's more in there","text":"<p>If you're still looking for something that you don't see in the above properties and methods, try looking through:</p> <ul> <li><code>ND2File.custom_data</code></li> <li><code>ND2File.unstructured_metadata()</code></li> </ul> <p>These methods parse and return more of the metadata found in the file, but no attempt is made to extract it into a more useful form.</p>"},{"location":"#export-nd2-to-ome-tiff","title":"Export nd2 to OME-TIFF","text":"<p>Requires extras</p> <p>In order to use <code>write_tiff</code> you must install <code>nd2</code> with the <code>tiff</code> extra:</p> <pre><code>pip install \"nd2[tiff]\"\n</code></pre> <p>To convert an nd2 file to an OME-TIFF file, use <code>nd2.ND2File.write_tiff</code> or the convenience function <code>nd2.nd2_to_tiff</code>:</p> <pre><code>import nd2\n\n\nnd2.nd2_to_tiff('some_file.nd2', 'new_file.ome.tiff', progress=True)\n\n# or with an ND2File object\n\nwith nd2.ND2File('some_file.nd2') as myfile:\n    myfile.write_tiff('my_file.ome.tiff', progress=True)\n</code></pre> <p>Note that if you simply want the OME metadata, you can use the <code>ome_metadata()</code> method to retrieve an instance of <code>ome_types.OME</code>:</p> <pre><code>with nd2.ND2File('some_file.nd2') as myfile:\n    ome_metadata = myfile.ome_metadata()\n</code></pre>"},{"location":"#export-nd2-to-ome-zarr","title":"Export nd2 to OME-Zarr","text":"<p>Requires extras</p> <p>In order to use <code>write_ome_zarr</code> you must install <code>nd2</code> with an appropriate array-writing backend.  <code>zarr-python</code> is the reference implementation, but <code>tensorstore</code> is faster.</p> <ul> <li><code>pip install \"nd2[ome-zarr-tensorstore]\"</code> (to use tensorstore backend)</li> <li><code>pip install \"nd2[ome-zarr]\"</code> (to use zarr-python backend)</li> </ul> <p>To convert an nd2 file to an OME-Zarr store, use <code>nd2.ND2File.write_ome_zarr</code>:</p> <pre><code>import nd2\n\nwith nd2.ND2File('some_file.nd2') as myfile:\n    myfile.write_ome_zarr('path/to/ome_zarr_store.ome.zarr')\n</code></pre> <p>See API documentation for complete details on options for chunking, etc.</p>"},{"location":"reference/nd2/","title":"nd2","text":""},{"location":"reference/nd2/#nd2","title":"nd2","text":"<p>nd2: A Python library for reading and writing ND2 files.</p> <p>Modules:</p> <ul> <li> <code>index</code>           \u2013            <p>Index ND2 files and print the results as a table.</p> </li> <li> <code>jobs</code>           \u2013            <p>JOBS support.</p> </li> <li> <code>structures</code>           \u2013            <p>Dataclasses and other structures used for metadata.</p> </li> <li> <code>tiff</code>           \u2013            <p>Functions for converting .nd2 to .tiff files.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>BinaryLayer</code>           \u2013            <p>Wrapper for data from a single binary layer in an <code>nd2.ND2File</code>.</p> </li> <li> <code>BinaryLayers</code>           \u2013            <p>Sequence of Binary Layers found in an ND2 file.</p> </li> <li> <code>ND2File</code>           \u2013            <p>Main objecting for opening and extracting data from an nd2 file.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>imread</code>             \u2013              <p>Open <code>file</code>, return requested array type, and close <code>file</code>.</p> </li> <li> <code>is_legacy</code>             \u2013              <p>Return <code>True</code> if <code>path</code> is a legacy ND2 file.</p> </li> <li> <code>is_supported_file</code>             \u2013              <p>Return <code>True</code> if <code>path</code> can be opened as an nd2 file.</p> </li> <li> <code>nd2_to_tiff</code>             \u2013              <p>Export an ND2 file to an (OME)-TIFF file.</p> </li> <li> <code>rescue_nd2</code>             \u2013              <p>Iterator that yields all discovered frames in a file handle.</p> </li> </ul>"},{"location":"reference/nd2/#nd2.BinaryLayer","title":"BinaryLayer  <code>dataclass</code>","text":"<pre><code>BinaryLayer(\n    data: list[ndarray | None],\n    name: str,\n    file_tag: str,\n    comp_name: str | None,\n    comp_order: int | None,\n    color: int | None,\n    color_mode: int | None,\n    state: int | None,\n    layer_id: int | None,\n    coordinate_shape: tuple[int, ...],\n)\n</code></pre> <p>Wrapper for data from a single binary layer in an <code>nd2.ND2File</code>.</p> <p>A \"layer\" is a set of binary data that can be associated with a specific component in an ND2 file, such as a single channel.</p> <p>This object behaves like a <code>list[numpy.ndarray] | None</code>. It will have a length matching the number of frames in the file, with <code>None</code> for any frames that lack binary data.</p> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>list[ndarray] | None</code>)           \u2013            <p>The data for each frame. If a frame has no binary data, the value will be None.  Data will have the same length as the number of sequences in the file.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the binary layer.</p> </li> <li> <code>comp_name</code>               (<code>str</code>)           \u2013            <p>The name of the associated component, if Any.</p> </li> <li> <code>comp_order</code>               (<code>int</code>)           \u2013            <p>The order of the associated component, if Any.</p> </li> <li> <code>color</code>               (<code>int</code>)           \u2013            <p>The color of the binary layer.</p> </li> <li> <code>color_mode</code>               (<code>int</code>)           \u2013            <p>The color mode of the binary layer.  I believe this is related to how colors are chosen in NIS-Elements software.  Where \"0\" is direct color (i.e. use, the color value), \"8\" is color by 3D ... and I'm not sure about the rest :)</p> </li> <li> <code>state</code>               (<code>int</code>)           \u2013            <p>The state of the binary layer. (meaning still unclear)</p> </li> <li> <code>file_tag</code>               (<code>str</code>)           \u2013            <p>The key for the binary layer in the CustomData metadata, e.g. <code>RleZipBinarySequence_1_v1</code></p> </li> <li> <code>layer_id</code>               (<code>int</code>)           \u2013            <p>The ID of the binary layer.</p> </li> <li> <code>coordinate_shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the coordinates for the associated nd2 file.  This is used to reshape the data into a 3D array in <code>asarray</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>asarray</code>             \u2013              <p>Stack all the frames into a single array.</p> </li> </ul>"},{"location":"reference/nd2/#nd2.BinaryLayer.frame_shape","title":"frame_shape  <code>property</code>","text":"<pre><code>frame_shape: tuple[int, ...]\n</code></pre> <p>Shape (Y, X) of each mask in <code>data</code>.</p>"},{"location":"reference/nd2/#nd2.BinaryLayer.asarray","title":"asarray","text":"<pre><code>asarray() -&gt; ndarray | None\n</code></pre> <p>Stack all the frames into a single array.</p> <p>If there are no frames, returns None.</p> Source code in <code>src/nd2/_binary.py</code> <pre><code>def asarray(self) -&gt; np.ndarray | None:\n    \"\"\"Stack all the frames into a single array.\n\n    If there are no frames, returns None.\n    \"\"\"\n    frame_shape = self.frame_shape\n    if frame_shape == (0, 0):\n        return None\n\n    # TODO: this is a bit of a hack (takes up memory), but it works for now\n    # could do something with dask\n    d = [\n        i if i is not None else np.zeros(frame_shape, dtype=\"uint16\")\n        for i in self.data\n    ]\n    return cast(\n        \"np.ndarray\", np.stack(d).reshape(self.coordinate_shape + frame_shape)\n    )\n</code></pre>"},{"location":"reference/nd2/#nd2.BinaryLayers","title":"BinaryLayers","text":"<pre><code>BinaryLayers(data: list[BinaryLayer])\n</code></pre> <p>Sequence of Binary Layers found in an ND2 file.</p> <p>This is the output type of <code>ND2File.binary_data</code>.</p> <p>This object is a sequence of <code>BinaryLayer</code> objects, one for each binary layer in the file.  Each layer has a <code>name</code> attribute, and a <code>data</code> attribute that is list of numpy arrays - one for each frame in the experiment - or None if the layer was not present in that frame.</p> <p>The wrapper can be cast to a numpy array (with <code>BinaryLayers.asarray()</code> or <code>np.asarray(BinaryLayers)</code>) to stack all the layers into a single array.  The output array will have shape <code>(n_layers, *coord_shape, *frame_shape)</code>.</p> <p>Methods:</p> <ul> <li> <code>asarray</code>             \u2013              <p>Stack all the layers/frames into a single array.</p> </li> </ul> Source code in <code>src/nd2/_binary.py</code> <pre><code>def __init__(self, data: list[BinaryLayer]) -&gt; None:\n    self._data = data\n</code></pre>"},{"location":"reference/nd2/#nd2.BinaryLayers.asarray","title":"asarray","text":"<pre><code>asarray() -&gt; ndarray\n</code></pre> <p>Stack all the layers/frames into a single array.</p> <p>The output array will have shape (n_layers, coord_shape, frame_shape).</p> Source code in <code>src/nd2/_binary.py</code> <pre><code>def asarray(self) -&gt; np.ndarray:\n    \"\"\"Stack all the layers/frames into a single array.\n\n    The output array will have shape (n_layers, *coord_shape, *frame_shape).\n    \"\"\"\n    out = []\n    for bin_layer in self._data:\n        d = bin_layer.asarray()\n        if d is not None:\n            out.append(d)\n    return np.stack(out)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File","title":"ND2File","text":"<pre><code>ND2File(\n    path: FileOrBinaryIO,\n    *,\n    validate_frames: bool = False,\n    search_window: int = 100,\n)\n</code></pre> <p>Main objecting for opening and extracting data from an nd2 file.</p> <pre><code>with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n    ...\n</code></pre> <p>The key metadata outputs are:</p> <ul> <li>attributes</li> <li>metadata / frame_metadata</li> <li>experiment</li> <li>text_info</li> </ul> <p>Some files may also have:</p> <ul> <li>binary_data</li> <li>rois</li> </ul> <p>Tip</p> <p>For a simple way to read nd2 file data into an array, see nd2.imread.</p> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>asarray</code>             \u2013              <p>Read image into a numpy.ndarray.</p> </li> <li> <code>close</code>             \u2013              <p>Close file.</p> </li> <li> <code>events</code>             \u2013              <p>Return tabular data recorded for each frame and/or event of the experiment.</p> </li> <li> <code>frame_metadata</code>             \u2013              <p>Metadata for specific frame.</p> </li> <li> <code>is_supported_file</code>             \u2013              <p>Return <code>True</code> if the file is supported by this reader.</p> </li> <li> <code>jobs</code>             \u2013              <p>Return JOBS metadata if the file was acquired using JOBS, else None.</p> </li> <li> <code>ome_metadata</code>             \u2013              <p>Return <code>ome_types.OME</code> metadata object for this file.</p> </li> <li> <code>open</code>             \u2013              <p>Open file for reading.</p> </li> <li> <code>read_frame</code>             \u2013              <p>Read a single frame from the file, indexed by frame number.</p> </li> <li> <code>to_dask</code>             \u2013              <p>Create dask array (delayed reader) representing image.</p> </li> <li> <code>to_xarray</code>             \u2013              <p>Return a labeled xarray.DataArray representing image.</p> </li> <li> <code>unstructured_metadata</code>             \u2013              <p>Exposes, and attempts to decode, each metadata chunk in the file.</p> </li> <li> <code>voxel_size</code>             \u2013              <p>XYZ voxel size in microns.</p> </li> <li> <code>write_ome_zarr</code>             \u2013              <p>Export to an OME-Zarr store.</p> </li> <li> <code>write_tiff</code>             \u2013              <p>Export to an (OME)-TIFF file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>attributes</code>               (<code>Attributes</code>)           \u2013            <p>Core image attributes.</p> </li> <li> <code>binary_data</code>               (<code>BinaryLayers | None</code>)           \u2013            <p>Return binary layers embedded in the file.</p> </li> <li> <code>closed</code>               (<code>bool</code>)           \u2013            <p>Return <code>True</code> if the file is closed.</p> </li> <li> <code>components_per_channel</code>               (<code>int</code>)           \u2013            <p>Number of components per channel (e.g. 3 for rgb).</p> </li> <li> <code>custom_data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Dict of various unstructured custom metadata.</p> </li> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Image data type.</p> </li> <li> <code>experiment</code>               (<code>list[ExpLoop]</code>)           \u2013            <p>Loop information for each axis of an nD acquisition.</p> </li> <li> <code>is_legacy</code>               (<code>bool</code>)           \u2013            <p>Whether file is a legacy nd2 (JPEG2000) file.</p> </li> <li> <code>is_rgb</code>               (<code>bool</code>)           \u2013            <p>Whether the image is rgb (i.e. it has 3 or 4 components per channel).</p> </li> <li> <code>loop_indices</code>               (<code>tuple[dict[str, int], ...]</code>)           \u2013            <p>Return a tuple of dicts of loop indices for each frame.</p> </li> <li> <code>metadata</code>               (<code>Metadata</code>)           \u2013            <p>Various metadata (will be <code>dict</code> only if legacy format).</p> </li> <li> <code>nbytes</code>               (<code>int</code>)           \u2013            <p>Total bytes of image data.</p> </li> <li> <code>ndim</code>               (<code>int</code>)           \u2013            <p>Number of dimensions (i.e. <code>len(</code><code>self.shape</code><code>)</code>).</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path of the image.</p> </li> <li> <code>rois</code>               (<code>dict[int, ROI]</code>)           \u2013            <p>Return dict of <code>{id: ROI}</code> for all ROIs found in the metadata.</p> </li> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>Size of each axis.</p> </li> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Total number of voxels in the volume (the product of the shape).</p> </li> <li> <code>sizes</code>               (<code>Mapping[str, int]</code>)           \u2013            <p>Names and sizes for each axis.</p> </li> <li> <code>text_info</code>               (<code>TextInfo</code>)           \u2013            <p>Miscellaneous text info.</p> </li> <li> <code>version</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>Return the file format version as a tuple of ints.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def __init__(\n    self,\n    path: FileOrBinaryIO,\n    *,\n    validate_frames: bool = False,\n    search_window: int = 100,\n) -&gt; None:\n    self._error_radius: int | None = (\n        search_window * 1000 if validate_frames else None\n    )\n    self._rdr = ND2Reader.create(path, self._error_radius)\n    self._path = self._rdr._path\n    self._lock = threading.RLock()\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File(path)","title":"<code>path</code>","text":"(<code>Path | str</code>)           \u2013            <p>Filename of an nd2 file.</p>"},{"location":"reference/nd2/#nd2.ND2File(validate_frames)","title":"<code>validate_frames</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to verify (and attempt to fix) frames whose positions have been shifted relative to the predicted offset (i.e. in a corrupted file). This comes at a slight performance penalty at file open, but may \"rescue\" some corrupt files. by default False.</p>"},{"location":"reference/nd2/#nd2.ND2File(search_window)","title":"<code>search_window</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>When validate_frames is true, this is the search window (in KB) that will be used to try to find the actual chunk position. by default 100 KB</p>"},{"location":"reference/nd2/#nd2.ND2File.attributes","title":"attributes  <code>cached</code> <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>Core image attributes.</p> <p>Example Output</p> <pre><code>Attributes(\n    bitsPerComponentInMemory=16,\n    bitsPerComponentSignificant=16,\n    componentCount=2,\n    heightPx=32,\n    pixelDataType=\"unsigned\",\n    sequenceCount=60,\n    widthBytes=128,\n    widthPx=32,\n    compressionLevel=None,\n    compressionType=None,\n    tileHeightPx=None,\n    tileWidthPx=None,\n    channelCount=2,\n)\n</code></pre> <p>Returns:</p> <ul> <li> <code>attrs</code> (              <code>Attributes</code> )          \u2013            <p>Core image attributes</p> </li> </ul>"},{"location":"reference/nd2/#nd2.ND2File.binary_data","title":"binary_data  <code>cached</code> <code>property</code>","text":"<pre><code>binary_data: BinaryLayers | None\n</code></pre> <p>Return binary layers embedded in the file.</p> <p>new in version 0.5.1</p> <p>The returned <code>BinaryLayers</code> object is an immutable sequence of <code>BinaryLayer</code> objects, one for each binary layer in the file (there will usually be a binary layer associated with each channel in the dataset).</p> <p>Each <code>BinaryLayer</code> object in the sequence has a <code>name</code> attribute, and a <code>data</code> attribute which is list of numpy arrays (or <code>None</code> if there was no binary mask for that frame).  The length of the list will be the same as the number of sequence frames in this file (i.e. <code>self.attributes.sequenceCount</code>). <code>BinaryLayers</code> can be indexed directly with an integer corresponding to the frame index.</p> <p>Both the <code>BinaryLayers</code> and individual <code>BinaryLayer</code> objects can be cast to a numpy array with <code>np.asarray()</code>, or by using the <code>.asarray()</code> method</p> <p>Returns:</p> <ul> <li> <code>BinaryLayers | None</code>           \u2013            <p>The binary layers embedded in the file, or None if there are no binary layers.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = ND2File(\"path/to/file.nd2\")\n&gt;&gt;&gt; f.binary_data\n&lt;BinaryLayers with 4 layers&gt;\n&gt;&gt;&gt; first_layer = f.binary_data[0]  # the first binary layer\n&gt;&gt;&gt; first_layer\nBinaryLayer(name='attached Widefield green (green color)',\ncomp_name='Widefield Green', comp_order=2, color=65280, color_mode=0,\nstate=524288, file_tag='RleZipBinarySequence_1_v1', layer_id=2)\n&gt;&gt;&gt; first_layer.data  # list of arrays\n# you can also index in to the BinaryLayers object itself\n&gt;&gt;&gt; first_layer[0]  # get binary data for first frame (or None if missing)\n&gt;&gt;&gt; np.asarray(first_layer)  # cast to array matching shape of full sequence\n&gt;&gt;&gt; np.asarray(f.binary_data).shape  # cast all layers to array\n(4, 3, 4, 5, 32, 32)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.closed","title":"closed  <code>property</code>","text":"<pre><code>closed: bool\n</code></pre> <p>Return <code>True</code> if the file is closed.</p>"},{"location":"reference/nd2/#nd2.ND2File.components_per_channel","title":"components_per_channel  <code>property</code>","text":"<pre><code>components_per_channel: int\n</code></pre> <p>Number of components per channel (e.g. 3 for rgb).</p>"},{"location":"reference/nd2/#nd2.ND2File.custom_data","title":"custom_data  <code>cached</code> <code>property</code>","text":"<pre><code>custom_data: dict[str, Any]\n</code></pre> <p>Dict of various unstructured custom metadata.</p>"},{"location":"reference/nd2/#nd2.ND2File.dtype","title":"dtype  <code>cached</code> <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Image data type.</p>"},{"location":"reference/nd2/#nd2.ND2File.experiment","title":"experiment  <code>cached</code> <code>property</code>","text":"<pre><code>experiment: list[ExpLoop]\n</code></pre> <p>Loop information for each axis of an nD acquisition.</p> Example Output <pre><code>[\n    TimeLoop(\n        count=3,\n        nestingLevel=0,\n        parameters=TimeLoopParams(\n            startMs=0.0,\n            periodMs=1.0,\n            durationMs=0.0,\n            periodDiff=PeriodDiff(\n                avg=3674.199951171875,\n                max=3701.219970703125,\n                min=3647.179931640625,\n            ),\n        ),\n        type=\"TimeLoop\",\n    ),\n    ZStackLoop(\n        count=5,\n        nestingLevel=1,\n        parameters=ZStackLoopParams(\n            homeIndex=2,\n            stepUm=1.0,\n            bottomToTop=True,\n            deviceName=\"Ti2 ZDrive\",\n        ),\n        type=\"ZStackLoop\",\n    ),\n]\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[ExpLoop]</code>           \u2013            </li> </ul>"},{"location":"reference/nd2/#nd2.ND2File.is_legacy","title":"is_legacy  <code>property</code>","text":"<pre><code>is_legacy: bool\n</code></pre> <p>Whether file is a legacy nd2 (JPEG2000) file.</p>"},{"location":"reference/nd2/#nd2.ND2File.is_rgb","title":"is_rgb  <code>property</code>","text":"<pre><code>is_rgb: bool\n</code></pre> <p>Whether the image is rgb (i.e. it has 3 or 4 components per channel).</p>"},{"location":"reference/nd2/#nd2.ND2File.loop_indices","title":"loop_indices  <code>cached</code> <code>property</code>","text":"<pre><code>loop_indices: tuple[dict[str, int], ...]\n</code></pre> <p>Return a tuple of dicts of loop indices for each frame.</p> <p>new in version 0.8.0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with nd2.ND2File(\"path/to/file.nd2\") as f:\n...     f.loop_indices\n(\n    {'Z': 0, 'T': 0, 'C': 0},\n    {'Z': 0, 'T': 0, 'C': 1},\n    {'Z': 0, 'T': 0, 'C': 2},\n    ...\n)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.metadata","title":"metadata  <code>cached</code> <code>property</code>","text":"<pre><code>metadata: Metadata\n</code></pre> <p>Various metadata (will be <code>dict</code> only if legacy format).</p> Example output <pre><code>Metadata(\n    contents=Contents(channelCount=2, frameCount=15),\n    channels=[\n        Channel(\n            channel=ChannelMeta(\n                name=\"Widefield Green\",\n                index=0,\n                color=Color(r=91, g=255, b=0, a=1.0),\n                emissionLambdaNm=535.0,\n                excitationLambdaNm=None,\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None, TimeLoop=0, XYPosLoop=None, ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName=\"Plan Fluor 10x Ph1 DLL\",\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=[\"fluorescence\"],\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[0.652452890023035, 0.652452890023035, 1.0],\n                axesInterpretation=[\"distance\", \"distance\", \"distance\"],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086,\n                ],\n                componentCount=1,\n                componentDataType=\"unsigned\",\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None,\n            ),\n        ),\n        Channel(\n            channel=ChannelMeta(\n                name=\"Widefield Red\",\n                index=1,\n                color=Color(r=255, g=85, b=0, a=1.0),\n                emissionLambdaNm=620.0,\n                excitationLambdaNm=None,\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None, TimeLoop=0, XYPosLoop=None, ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName=\"Plan Fluor 10x Ph1 DLL\",\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=[\"fluorescence\"],\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[0.652452890023035, 0.652452890023035, 1.0],\n                axesInterpretation=[\"distance\", \"distance\", \"distance\"],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086,\n                ],\n                componentCount=1,\n                componentDataType=\"unsigned\",\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None,\n            ),\n        ),\n    ],\n)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Metadata | dict</code>           \u2013            <p>dict if legacy format, else <code>Metadata</code></p> </li> </ul>"},{"location":"reference/nd2/#nd2.ND2File.nbytes","title":"nbytes  <code>property</code>","text":"<pre><code>nbytes: int\n</code></pre> <p>Total bytes of image data.</p>"},{"location":"reference/nd2/#nd2.ND2File.ndim","title":"ndim  <code>cached</code> <code>property</code>","text":"<pre><code>ndim: int\n</code></pre> <p>Number of dimensions (i.e. <code>len(</code><code>self.shape</code><code>)</code>).</p>"},{"location":"reference/nd2/#nd2.ND2File.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the image.</p>"},{"location":"reference/nd2/#nd2.ND2File.rois","title":"rois  <code>cached</code> <code>property</code>","text":"<pre><code>rois: dict[int, ROI]\n</code></pre> <p>Return dict of <code>{id: ROI}</code> for all ROIs found in the metadata.</p> <p>new in version 0.4.6</p> <p>Returns:</p> <ul> <li> <code>dict[int, ROI]</code>           \u2013            <p>The dict of ROIs is keyed by the ROI ID.</p> </li> </ul>"},{"location":"reference/nd2/#nd2.ND2File.shape","title":"shape  <code>cached</code> <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Size of each axis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ndfile.shape\n(3, 5, 2, 512, 512)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Total number of voxels in the volume (the product of the shape).</p>"},{"location":"reference/nd2/#nd2.ND2File.sizes","title":"sizes  <code>cached</code> <code>property</code>","text":"<pre><code>sizes: Mapping[str, int]\n</code></pre> <p>Names and sizes for each axis.</p> <p>This is an ordered dict, with the same order as the corresponding shape</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ndfile.sizes\n{'T': 3, 'Z': 5, 'C': 2, 'Y': 512, 'X': 512}\n&gt;&gt;&gt; ndfile.shape\n(3, 5, 2, 512, 512)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.text_info","title":"text_info  <code>cached</code> <code>property</code>","text":"<pre><code>text_info: TextInfo\n</code></pre> <p>Miscellaneous text info.</p> Example Output <pre><code>{\n    'description': 'Metadata:\\r\\nDimensions: T(3) x XY(4) x \u03bb(2) x Z(5)...'\n    'capturing': 'Flash4.0, SN:101412\\r\\nSample 1:\\r\\n  Exposure: 100 ms...'\n    'date': '9/28/2021  9:41:27 AM',\n    'optics': 'Plan Fluor 10x Ph1 DLL'\n}\n</code></pre> <p>Returns:</p> <ul> <li> <code>TextInfo | dict</code>           \u2013            <p>If the file is a legacy nd2 file, a dict is returned. Otherwise, a <code>TextInfo</code> object is returned.</p> </li> </ul>"},{"location":"reference/nd2/#nd2.ND2File.version","title":"version  <code>cached</code> <code>property</code>","text":"<pre><code>version: tuple[int, ...]\n</code></pre> <p>Return the file format version as a tuple of ints.</p> <p>new in version 0.6.1</p> <p>Likely values are:</p> <ul> <li><code>(1, 0)</code> = a legacy nd2 file (JPEG2000)</li> <li><code>(2, 0)</code>, <code>(2, 1)</code> = non-JPEG2000 nd2 with xml metadata</li> <li><code>(3, 0)</code> = new format nd2 file with lite variant metadata</li> <li><code>(-1, -1)</code> =</li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>The file format version as a tuple of ints.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the file is not a valid nd2 file.</p> </li> </ul>"},{"location":"reference/nd2/#nd2.ND2File.asarray","title":"asarray","text":"<pre><code>asarray(position: int | None = None) -&gt; ndarray\n</code></pre> <p>Read image into a numpy.ndarray.</p> <p>For a simple way to read a file into a numpy array, see nd2.imread.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>array</code> (              <code>ndarray</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if <code>position</code> is a string and is not a valid position name</p> </li> <li> <code>IndexError</code>             \u2013            <p>if <code>position</code> is provided and is out of range</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def asarray(self, position: int | None = None) -&gt; np.ndarray:\n    \"\"\"Read image into a [numpy.ndarray][].\n\n    For a simple way to read a file into a numpy array, see [nd2.imread][].\n\n    Parameters\n    ----------\n    position : int, optional\n        A specific XY position to extract, by default (None) reads all.\n\n    Returns\n    -------\n    array : np.ndarray\n\n    Raises\n    ------\n    ValueError\n        if `position` is a string and is not a valid position name\n    IndexError\n        if `position` is provided and is out of range\n    \"\"\"\n    final_shape = list(self.shape)\n    if position is None:\n        seqs: Sequence[int] = range(self._frame_count)\n    else:\n        if isinstance(position, str):\n            try:\n                position = self._position_names().index(position)\n            except ValueError as e:\n                raise ValueError(\n                    f\"{position!r} is not a valid position name\"\n                ) from e\n        try:\n            pidx = list(self.sizes).index(AXIS.POSITION)\n        except ValueError as exc:\n            if position &gt; 0:  # pragma: no cover\n                raise IndexError(\n                    f\"Position {position} is out of range. \"\n                    f\"Only 1 position available\"\n                ) from exc\n            seqs = range(self._frame_count)\n        else:\n            if position &gt;= self.sizes[AXIS.POSITION]:\n                raise IndexError(  # pragma: no cover\n                    f\"Position {position} is out of range. \"\n                    f\"Only {self.sizes[AXIS.POSITION]} positions available\"\n                )\n\n            ranges: list[range | tuple] = [range(x) for x in self._coord_shape]\n            ranges[pidx] = (position,)\n            coords = list(zip(*product(*ranges)))\n            seqs = self._seq_index_from_coords(coords)  # type: ignore\n            final_shape[pidx] = 1\n\n    arr: np.ndarray = np.stack([self.read_frame(i) for i in seqs])\n    return arr.reshape(final_shape)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.asarray(position)","title":"<code>position</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>A specific XY position to extract, by default (None) reads all.</p>"},{"location":"reference/nd2/#nd2.ND2File.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close file.</p> <p>Note</p> <p>Files are best opened using a context manager:</p> <pre><code>with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n    ...\n</code></pre> <p>This will automatically close the file when the context exits.</p> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close file.\n\n    !!! note\n\n        Files are best opened using a context manager:\n\n        ```python\n        with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n            ...\n        ```\n\n        This will automatically close the file when the context exits.\n    \"\"\"\n    if not self.closed:\n        self._rdr.close()\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.events","title":"events","text":"<pre><code>events(\n    *,\n    orient: Literal[\"records\"] = ...,\n    null_value: Any = ...,\n) -&gt; ListOfDicts\n</code></pre><pre><code>events(\n    *, orient: Literal[\"list\"], null_value: Any = ...\n) -&gt; DictOfLists\n</code></pre><pre><code>events(\n    *, orient: Literal[\"dict\"], null_value: Any = ...\n) -&gt; DictOfDicts\n</code></pre> <pre><code>events(\n    *,\n    orient: Literal[\"records\", \"list\", \"dict\"] = \"records\",\n    null_value: Any = float(\"nan\"),\n) -&gt; ListOfDicts | DictOfLists | DictOfDicts\n</code></pre> <p>Return tabular data recorded for each frame and/or event of the experiment.</p> <p>new in version 0.6.1</p> <p>This method returns tabular data in the format specified by the <code>orient</code> argument:     - 'records' : list of dict - <code>[{column -&gt; value}, ...]</code> (default)     - 'dict' :    dict of dict - <code>{column -&gt; {index -&gt; value}, ...}</code>     - 'list' :    dict of list - <code>{column -&gt; [value, ...]}</code></p> <p>All return types are passable to pd.DataFrame(). It matches the tabular data reported in the Image Properties &gt; Recorded Data tab of the NIS Viewer.</p> <p>There will be a column for each tag in the <code>CustomDataV2_0</code> section of <code>ND2File.custom_data</code>, as well columns for any events recorded in the data.  Not all cells will be populated, and empty cells will be filled with <code>null_value</code> (default <code>float('nan')</code>).</p> <p>Legacy ND2 files are not supported.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ListOfDicts | DictOfLists | DictOfDicts</code>           \u2013            <p>Tabular data in the format specified by <code>orient</code>.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def events(\n    self,\n    *,\n    orient: Literal[\"records\", \"list\", \"dict\"] = \"records\",\n    null_value: Any = float(\"nan\"),\n) -&gt; ListOfDicts | DictOfLists | DictOfDicts:\n    \"\"\"Return tabular data recorded for each frame and/or event of the experiment.\n\n    !!! Tip \"new in version 0.6.1\"\n\n    This method returns tabular data in the format specified by the `orient`\n    argument:\n        - 'records' : list of dict - `[{column -&gt; value}, ...]` (default)\n        - 'dict' :    dict of dict - `{column -&gt; {index -&gt; value}, ...}`\n        - 'list' :    dict of list - `{column -&gt; [value, ...]}`\n\n    All return types are passable to pd.DataFrame(). It matches the tabular data\n    reported in the Image Properties &gt; Recorded Data tab of the NIS Viewer.\n\n    There will be a column for each tag in the `CustomDataV2_0` section of\n    `ND2File.custom_data`, as well columns for any events recorded in the\n    data.  Not all cells will be populated, and empty cells will be filled\n    with `null_value` (default `float('nan')`).\n\n    Legacy ND2 files are not supported.\n\n    Parameters\n    ----------\n    orient : {'records', 'dict', 'list'}, default 'records'\n        The format of the returned data. See `pandas.DataFrame\n            - 'records' : list of dict - `[{column -&gt; value}, ...]` (default)\n            - 'dict' :    dict of dict - `{column -&gt; {index -&gt; value}, ...}`\n            - 'list' :    dict of list - `{column -&gt; [value, ...]}`\n    null_value : Any, default float('nan')\n        The value to use for missing data.\n\n\n    Returns\n    -------\n    ListOfDicts | DictOfLists | DictOfDicts\n        Tabular data in the format specified by `orient`.\n    \"\"\"\n    if orient not in (\"records\", \"dict\", \"list\"):  # pragma: no cover\n        raise ValueError(\"orient must be one of 'records', 'dict', or 'list'\")\n\n    return self._rdr.events(orient=orient, null_value=null_value)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.events(orient)","title":"<code>orient</code>","text":"(<code>('records', 'dict', 'list')</code>, default:                   <code>'records'</code> )           \u2013            <p>The format of the returned data. See <code>pandas.DataFrame     - 'records' : list of dict -</code>[{column -&gt; value}, ...]<code>(default)     - 'dict' :    dict of dict -</code>{column -&gt; {index -&gt; value}, ...}<code>- 'list' :    dict of list -</code>{column -&gt; [value, ...]}`</p>"},{"location":"reference/nd2/#nd2.ND2File.events(null_value)","title":"<code>null_value</code>","text":"(<code>Any</code>, default:                   <code>float('nan')</code> )           \u2013            <p>The value to use for missing data.</p>"},{"location":"reference/nd2/#nd2.ND2File.frame_metadata","title":"frame_metadata","text":"<pre><code>frame_metadata(\n    seq_index: int | tuple,\n) -&gt; FrameMetadata | dict\n</code></pre> <p>Metadata for specific frame.</p> <p> See also: metadata</p> <p>This includes the global metadata from the metadata function. (will be dict if legacy format).</p> Example output <pre><code>FrameMetadata(\n    contents=Contents(channelCount=2, frameCount=15),\n    channels=[\n        FrameChannel(\n            channel=ChannelMeta(\n                name=\"Widefield Green\",\n                index=0,\n                color=Color(r=91, g=255, b=0, a=1.0),\n                emissionLambdaNm=535.0,\n                excitationLambdaNm=None,\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None, TimeLoop=0, XYPosLoop=None, ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName=\"Plan Fluor 10x Ph1 DLL\",\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=[\"fluorescence\"],\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[0.652452890023035, 0.652452890023035, 1.0],\n                axesInterpretation=[\"distance\", \"distance\", \"distance\"],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086,\n                ],\n                componentCount=1,\n                componentDataType=\"unsigned\",\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None,\n            ),\n            position=Position(\n                stagePositionUm=StagePosition(\n                    x=26950.2, y=-1801.6000000000001, z=494.3\n                ),\n                pfsOffset=None,\n                name=None,\n            ),\n            time=TimeStamp(\n                absoluteJulianDayNumber=2459486.0682717753,\n                relativeTimeMs=580.3582921028137,\n            ),\n        ),\n        FrameChannel(\n            channel=ChannelMeta(\n                name=\"Widefield Red\",\n                index=1,\n                color=Color(r=255, g=85, b=0, a=1.0),\n                emissionLambdaNm=620.0,\n                excitationLambdaNm=None,\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None, TimeLoop=0, XYPosLoop=None, ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName=\"Plan Fluor 10x Ph1 DLL\",\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=[\"fluorescence\"],\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[0.652452890023035, 0.652452890023035, 1.0],\n                axesInterpretation=[\"distance\", \"distance\", \"distance\"],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086,\n                ],\n                componentCount=1,\n                componentDataType=\"unsigned\",\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None,\n            ),\n            position=Position(\n                stagePositionUm=StagePosition(\n                    x=26950.2, y=-1801.6000000000001, z=494.3\n                ),\n                pfsOffset=None,\n                name=None,\n            ),\n            time=TimeStamp(\n                absoluteJulianDayNumber=2459486.0682717753,\n                relativeTimeMs=580.3582921028137,\n            ),\n        ),\n    ],\n)\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>FrameMetadata | dict</code>           \u2013            <p>dict if legacy format, else FrameMetadata</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def frame_metadata(self, seq_index: int | tuple) -&gt; FrameMetadata | dict:\n    \"\"\"Metadata for specific frame.\n\n    :eyes: **See also:** [metadata][nd2.ND2File.metadata]\n\n    This includes the global metadata from the metadata function.\n    (will be dict if legacy format).\n\n    ??? example \"Example output\"\n\n        ```python\n        FrameMetadata(\n            contents=Contents(channelCount=2, frameCount=15),\n            channels=[\n                FrameChannel(\n                    channel=ChannelMeta(\n                        name=\"Widefield Green\",\n                        index=0,\n                        color=Color(r=91, g=255, b=0, a=1.0),\n                        emissionLambdaNm=535.0,\n                        excitationLambdaNm=None,\n                    ),\n                    loops=LoopIndices(\n                        NETimeLoop=None, TimeLoop=0, XYPosLoop=None, ZStackLoop=1\n                    ),\n                    microscope=Microscope(\n                        objectiveMagnification=10.0,\n                        objectiveName=\"Plan Fluor 10x Ph1 DLL\",\n                        objectiveNumericalAperture=0.3,\n                        zoomMagnification=1.0,\n                        immersionRefractiveIndex=1.0,\n                        projectiveMagnification=None,\n                        pinholeDiameterUm=None,\n                        modalityFlags=[\"fluorescence\"],\n                    ),\n                    volume=Volume(\n                        axesCalibrated=[True, True, True],\n                        axesCalibration=[0.652452890023035, 0.652452890023035, 1.0],\n                        axesInterpretation=[\"distance\", \"distance\", \"distance\"],\n                        bitsPerComponentInMemory=16,\n                        bitsPerComponentSignificant=16,\n                        cameraTransformationMatrix=[\n                            -0.9998932296054086,\n                            -0.014612644841559427,\n                            0.014612644841559427,\n                            -0.9998932296054086,\n                        ],\n                        componentCount=1,\n                        componentDataType=\"unsigned\",\n                        voxelCount=[32, 32, 5],\n                        componentMaxima=[0.0],\n                        componentMinima=[0.0],\n                        pixelToStageTransformationMatrix=None,\n                    ),\n                    position=Position(\n                        stagePositionUm=StagePosition(\n                            x=26950.2, y=-1801.6000000000001, z=494.3\n                        ),\n                        pfsOffset=None,\n                        name=None,\n                    ),\n                    time=TimeStamp(\n                        absoluteJulianDayNumber=2459486.0682717753,\n                        relativeTimeMs=580.3582921028137,\n                    ),\n                ),\n                FrameChannel(\n                    channel=ChannelMeta(\n                        name=\"Widefield Red\",\n                        index=1,\n                        color=Color(r=255, g=85, b=0, a=1.0),\n                        emissionLambdaNm=620.0,\n                        excitationLambdaNm=None,\n                    ),\n                    loops=LoopIndices(\n                        NETimeLoop=None, TimeLoop=0, XYPosLoop=None, ZStackLoop=1\n                    ),\n                    microscope=Microscope(\n                        objectiveMagnification=10.0,\n                        objectiveName=\"Plan Fluor 10x Ph1 DLL\",\n                        objectiveNumericalAperture=0.3,\n                        zoomMagnification=1.0,\n                        immersionRefractiveIndex=1.0,\n                        projectiveMagnification=None,\n                        pinholeDiameterUm=None,\n                        modalityFlags=[\"fluorescence\"],\n                    ),\n                    volume=Volume(\n                        axesCalibrated=[True, True, True],\n                        axesCalibration=[0.652452890023035, 0.652452890023035, 1.0],\n                        axesInterpretation=[\"distance\", \"distance\", \"distance\"],\n                        bitsPerComponentInMemory=16,\n                        bitsPerComponentSignificant=16,\n                        cameraTransformationMatrix=[\n                            -0.9998932296054086,\n                            -0.014612644841559427,\n                            0.014612644841559427,\n                            -0.9998932296054086,\n                        ],\n                        componentCount=1,\n                        componentDataType=\"unsigned\",\n                        voxelCount=[32, 32, 5],\n                        componentMaxima=[0.0],\n                        componentMinima=[0.0],\n                        pixelToStageTransformationMatrix=None,\n                    ),\n                    position=Position(\n                        stagePositionUm=StagePosition(\n                            x=26950.2, y=-1801.6000000000001, z=494.3\n                        ),\n                        pfsOffset=None,\n                        name=None,\n                    ),\n                    time=TimeStamp(\n                        absoluteJulianDayNumber=2459486.0682717753,\n                        relativeTimeMs=580.3582921028137,\n                    ),\n                ),\n            ],\n        )\n        ```\n\n    Parameters\n    ----------\n    seq_index : Union[int, tuple]\n        frame index\n\n    Returns\n    -------\n    FrameMetadata | dict\n        dict if legacy format, else FrameMetadata\n    \"\"\"\n    idx = cast(\n        \"int\",\n        (\n            self._seq_index_from_coords(seq_index)\n            if isinstance(seq_index, tuple)\n            else seq_index\n        ),\n    )\n    return self._rdr.frame_metadata(idx)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.frame_metadata(seq_index)","title":"<code>seq_index</code>","text":"(<code>Union[int, tuple]</code>)           \u2013            <p>frame index</p>"},{"location":"reference/nd2/#nd2.ND2File.is_supported_file","title":"is_supported_file  <code>staticmethod</code>","text":"<pre><code>is_supported_file(path: StrOrPath) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the file is supported by this reader.</p> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>@staticmethod\ndef is_supported_file(path: StrOrPath) -&gt; bool:\n    \"\"\"Return `True` if the file is supported by this reader.\"\"\"\n    return is_supported_file(path)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.jobs","title":"jobs","text":"<pre><code>jobs() -&gt; JobsDict | None\n</code></pre> <p>Return JOBS metadata if the file was acquired using JOBS, else None.</p> <p>new in version 0.11.0</p> <p>JOBS is a software feature in NIS Elements for automated acquisition workflows. Files acquired with JOBS contain metadata about the job definition, including task definitions and wellplate configurations.</p> <p>The metadata is returned as a dictionary, and there are a lot of possible types of JOBS definitions. You refer to <code>nd2.jobs.types</code> to see the typical structure of these dictionaries (inferred from real-world jobs files). But <code>nd2.jobs.types</code> should only ever be used for type hinting, and not imported at runtime.</p> <p>Returns:</p> <ul> <li> <code>dict | None</code>           \u2013            <p>A dictionary with JOBS metadata, or None if the file was not acquired using JOBS. The dictionary contains:</p> <ul> <li><code>\"JobRunGUID\"</code>: str - Unique identifier for the job run</li> <li><code>\"ProgramDesc\"</code>: dict - Job description including JobDefType</li> <li><code>\"Job\"</code>: dict | None - Full job definition (None if encrypted)</li> <li><code>\"ProtectedJob\"</code>: dict | None - Encryption info (if encrypted)</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with nd2.ND2File(\"path/to/jobs_file.nd2\") as f:\n...     if jobs := f.jobs():\n...         print(jobs[\"JobRunGUID\"])\n...         if jobs[\"Job\"]:\n...             print(list(jobs[\"Job\"][\"Tasks\"].keys()))\n</code></pre> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def jobs(self) -&gt; JobsDict | None:\n    \"\"\"Return JOBS metadata if the file was acquired using JOBS, else None.\n\n    !!! Tip \"new in version 0.11.0\"\n\n    JOBS is a software feature in NIS Elements for automated acquisition workflows.\n    Files acquired with JOBS contain metadata about the job definition,\n    including task definitions and wellplate configurations.\n\n    The metadata is returned as a dictionary, and there are a *lot* of possible\n    types of JOBS definitions. You refer to `nd2.jobs.types` to see the typical\n    structure of these dictionaries (inferred from real-world jobs files).\n    But `nd2.jobs.types` should only ever be used for type hinting, and not imported\n    at runtime.\n\n    Returns\n    -------\n    dict | None\n        A dictionary with JOBS metadata, or None if the file was not\n        acquired using JOBS. The dictionary contains:\n\n        - `\"JobRunGUID\"`: str - Unique identifier for the job run\n        - `\"ProgramDesc\"`: dict - Job description including JobDefType\n        - `\"Job\"`: dict | None - Full job definition (None if encrypted)\n        - `\"ProtectedJob\"`: dict | None - Encryption info (if encrypted)\n\n    Examples\n    --------\n    &gt;&gt;&gt; with nd2.ND2File(\"path/to/jobs_file.nd2\") as f:\n    ...     if jobs := f.jobs():\n    ...         print(jobs[\"JobRunGUID\"])\n    ...         if jobs[\"Job\"]:\n    ...             print(list(jobs[\"Job\"][\"Tasks\"].keys()))\n    \"\"\"\n    return self._rdr.jobs()\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.ome_metadata","title":"ome_metadata","text":"<pre><code>ome_metadata(\n    *,\n    include_unstructured: bool = True,\n    tiff_file_name: str | None = None,\n) -&gt; OME\n</code></pre> <p>Return <code>ome_types.OME</code> metadata object for this file.</p> <p>new in version 0.7.0</p> <p>See the <code>ome_types.OME</code> documentation for details on this object.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>import nd2\n\nwith nd2.ND2File(\"path/to/file.nd2\") as f:\n    ome = f.ome_metadata()\n    xml = ome.to_xml()\n</code></pre> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def ome_metadata(\n    self, *, include_unstructured: bool = True, tiff_file_name: str | None = None\n) -&gt; OME:\n    \"\"\"Return `ome_types.OME` metadata object for this file.\n\n    !!! Tip \"new in version 0.7.0\"\n\n    See the [`ome_types.OME`][] documentation for details on this object.\n\n    Parameters\n    ----------\n    include_unstructured : bool\n        Whether to include all available metadata in the OME file. If `True`,\n        (the default), the `unstructured_metadata` method is used to fetch\n        all retrievable metadata, and the output is added to\n        OME.structured_annotations, where each key is the chunk key, and the\n        value is a JSON-serialized dict of the metadata. If `False`, only metadata\n        which can be directly added to the OME data model are included.\n    tiff_file_name : str | None\n        If provided, [`ome_types.model.TiffData`][] block entries are added for\n        each [`ome_types.model.Plane`][] in the OME object, with the\n        `TiffData.uuid.file_name` set to this value. (Useful for exporting to\n        tiff.)\n\n    Examples\n    --------\n    ```python\n    import nd2\n\n    with nd2.ND2File(\"path/to/file.nd2\") as f:\n        ome = f.ome_metadata()\n        xml = ome.to_xml()\n    ```\n    \"\"\"\n    from ._ome import nd2_ome_metadata\n\n    return nd2_ome_metadata(\n        self,\n        include_unstructured=include_unstructured,\n        tiff_file_name=tiff_file_name,\n    )\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.ome_metadata(include_unstructured)","title":"<code>include_unstructured</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include all available metadata in the OME file. If <code>True</code>, (the default), the <code>unstructured_metadata</code> method is used to fetch all retrievable metadata, and the output is added to OME.structured_annotations, where each key is the chunk key, and the value is a JSON-serialized dict of the metadata. If <code>False</code>, only metadata which can be directly added to the OME data model are included.</p>"},{"location":"reference/nd2/#nd2.ND2File.ome_metadata(tiff_file_name)","title":"<code>tiff_file_name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, <code>ome_types.model.TiffData</code> block entries are added for each <code>ome_types.model.Plane</code> in the OME object, with the <code>TiffData.uuid.file_name</code> set to this value. (Useful for exporting to tiff.)</p>"},{"location":"reference/nd2/#nd2.ND2File.open","title":"open","text":"<pre><code>open() -&gt; None\n</code></pre> <p>Open file for reading.</p> <p>Note</p> <p>Files are best opened using a context manager:</p> <pre><code>with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n    ...\n</code></pre> <p>This will automatically close the file when the context exits.</p> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def open(self) -&gt; None:\n    \"\"\"Open file for reading.\n\n    !!! note\n\n        Files are best opened using a context manager:\n\n        ```python\n        with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n            ...\n        ```\n\n        This will automatically close the file when the context exits.\n    \"\"\"\n    if self.closed:\n        self._rdr.open()\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.read_frame","title":"read_frame","text":"<pre><code>read_frame(frame_index: SupportsInt) -&gt; ndarray\n</code></pre> <p>Read a single frame from the file, indexed by frame number.</p> <p>new in version 0.8.0</p> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def read_frame(self, frame_index: SupportsInt) -&gt; np.ndarray:\n    \"\"\"Read a single frame from the file, indexed by frame number.\n\n    !!! Tip \"new in version 0.8.0\"\n    \"\"\"\n    frame = self._rdr.read_frame(int(frame_index))\n    frame.shape = self._raw_frame_shape\n    return frame.transpose((2, 0, 1, 3)).squeeze()\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.to_dask","title":"to_dask","text":"<pre><code>to_dask(wrapper: bool = True, copy: bool = True) -&gt; Array\n</code></pre> <p>Create dask array (delayed reader) representing image.</p> <p>This generally works well, but it remains to be seen whether performance is optimized, or if we're duplicating safety mechanisms. You may try various combinations of <code>wrapper</code> and <code>copy</code>, setting both to <code>False</code> will very likely cause segmentation faults in many cases.  But setting one of them to <code>False</code>, may slightly improve read speed in certain cases.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dask_array</code> (              <code>Array</code> )          \u2013            <p>A dask array representing the image data.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def to_dask(self, wrapper: bool = True, copy: bool = True) -&gt; dask.array.core.Array:\n    \"\"\"Create dask array (delayed reader) representing image.\n\n    This generally works well, but it remains to be seen whether performance\n    is optimized, or if we're duplicating safety mechanisms. You may try\n    various combinations of `wrapper` and `copy`, setting both to `False`\n    will very likely cause segmentation faults in many cases.  But setting\n    one of them to `False`, may slightly improve read speed in certain\n    cases.\n\n    Parameters\n    ----------\n    wrapper : bool\n        If `True` (the default), the returned object will be a thin subclass of a\n        [`dask.array.Array`][] (a `ResourceBackedDaskArray`) that manages the\n        opening and closing of this file when getting chunks via compute(). If\n        `wrapper` is `False`, then a pure `dask.array.core.Array` will be returned.\n        However, when that array is computed, it will incur a file open/close on\n        *every* chunk that is read (in the `_dask_block` method).  As such `wrapper`\n        will generally be much faster, however, it *may* fail (i.e. result in\n        segmentation faults) with certain dask schedulers.\n    copy : bool\n        If `True` (the default), the dask chunk-reading function will return\n        an array copy. This can avoid segfaults in certain cases, though it\n        may also add overhead.\n\n    Returns\n    -------\n    dask_array: dask.array.Array\n        A dask array representing the image data.\n    \"\"\"\n    from dask.array.core import map_blocks\n\n    chunks = [(1,) * x for x in self._coord_shape]\n    chunks += [(x,) for x in self._frame_shape]\n    dask_arr = map_blocks(\n        self._dask_block,\n        copy=copy,\n        chunks=chunks,\n        dtype=self.dtype,\n    )\n    if wrapper:\n        from resource_backed_dask_array import ResourceBackedDaskArray\n\n        # this subtype allows the dask array to re-open the underlying\n        # nd2 file on compute.\n        return ResourceBackedDaskArray.from_array(dask_arr, self)\n    return dask_arr\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.to_dask(wrapper)","title":"<code>wrapper</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> (the default), the returned object will be a thin subclass of a <code>dask.array.Array</code> (a <code>ResourceBackedDaskArray</code>) that manages the opening and closing of this file when getting chunks via compute(). If <code>wrapper</code> is <code>False</code>, then a pure <code>dask.array.core.Array</code> will be returned. However, when that array is computed, it will incur a file open/close on every chunk that is read (in the <code>_dask_block</code> method).  As such <code>wrapper</code> will generally be much faster, however, it may fail (i.e. result in segmentation faults) with certain dask schedulers.</p>"},{"location":"reference/nd2/#nd2.ND2File.to_dask(copy)","title":"<code>copy</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> (the default), the dask chunk-reading function will return an array copy. This can avoid segfaults in certain cases, though it may also add overhead.</p>"},{"location":"reference/nd2/#nd2.ND2File.to_xarray","title":"to_xarray","text":"<pre><code>to_xarray(\n    delayed: bool = True,\n    squeeze: bool = True,\n    position: int | None = None,\n    copy: bool = True,\n) -&gt; DataArray\n</code></pre> <p>Return a labeled xarray.DataArray representing image.</p> <p>Xarrays are a powerful way to label and manipulate n-dimensional data with axis-associated coordinates.</p> <p><code>array.dims</code> will be populated according to image metadata, and coordinates will be populated based on pixel spacings. Additional metadata is available in <code>array.attrs['metadata']</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataArray</code>           \u2013            <p>xarray with all axes labeled.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def to_xarray(\n    self,\n    delayed: bool = True,\n    squeeze: bool = True,\n    position: int | None = None,\n    copy: bool = True,\n) -&gt; xr.DataArray:\n    \"\"\"Return a labeled [xarray.DataArray][] representing image.\n\n    Xarrays are a powerful way to label and manipulate n-dimensional data with\n    axis-associated coordinates.\n\n    `array.dims` will be populated according to image metadata, and coordinates\n    will be populated based on pixel spacings. Additional metadata is available\n    in `array.attrs['metadata']`.\n\n    Parameters\n    ----------\n    delayed : bool\n        Whether the DataArray should be backed by dask array or numpy array,\n        by default True (dask).\n    squeeze : bool\n        Whether to squeeze singleton dimensions, by default True\n    position : int, optional\n        A specific XY position to extract, by default (None) reads all.\n    copy : bool\n        Only applies when `delayed==True`.  See `to_dask` for details.\n\n    Returns\n    -------\n    xr.DataArray\n        xarray with all axes labeled.\n    \"\"\"\n    import xarray as xr\n\n    data = self.to_dask(copy=copy) if delayed else self.asarray(position)\n    dims = list(self.sizes)\n    coords = self._expand_coords(squeeze)\n    if not squeeze:\n        for missing_dim in set(coords).difference(dims):\n            dims.insert(0, missing_dim)\n        missing_axes = len(dims) - data.ndim\n        if missing_axes &gt; 0:\n            data = data[(np.newaxis,) * missing_axes]\n\n    if position is not None and not delayed and AXIS.POSITION in coords:\n        # if it's delayed, we do this using isel below instead.\n        coords[AXIS.POSITION] = [coords[AXIS.POSITION][position]]\n\n    x = xr.DataArray(\n        data,\n        dims=dims,\n        coords=coords,\n        attrs={\n            \"metadata\": {\n                \"metadata\": self.metadata,\n                \"experiment\": self.experiment,\n                \"attributes\": self.attributes,\n                \"text_info\": self.text_info,\n            }\n        },\n    )\n    if delayed and position is not None and AXIS.POSITION in coords:\n        x = x.isel({AXIS.POSITION: [position]})\n    return x.squeeze() if squeeze else x\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.to_xarray(delayed)","title":"<code>delayed</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the DataArray should be backed by dask array or numpy array, by default True (dask).</p>"},{"location":"reference/nd2/#nd2.ND2File.to_xarray(squeeze)","title":"<code>squeeze</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to squeeze singleton dimensions, by default True</p>"},{"location":"reference/nd2/#nd2.ND2File.to_xarray(position)","title":"<code>position</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>A specific XY position to extract, by default (None) reads all.</p>"},{"location":"reference/nd2/#nd2.ND2File.to_xarray(copy)","title":"<code>copy</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only applies when <code>delayed==True</code>.  See <code>to_dask</code> for details.</p>"},{"location":"reference/nd2/#nd2.ND2File.unstructured_metadata","title":"unstructured_metadata","text":"<pre><code>unstructured_metadata(\n    *,\n    strip_prefix: bool = True,\n    include: set[str] | None = None,\n    exclude: set[str] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Exposes, and attempts to decode, each metadata chunk in the file.</p> <p>new in version 0.4.3</p> <p>This is provided as a experimental fallback in the event that <code>ND2File.experiment</code> does not contain all of the information you need. No attempt is made to parse or validate the metadata, and the format of various sections, may change in future versions of nd2. Consumption of this metadata should use appropriate exception handling!</p> <p>The 'ImageMetadataLV' chunk is the most likely to contain useful information, but if you're generally looking for \"hidden\" metadata, it may be helpful to look at the full output.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dict of the unstructured metadata, with keys that are the type of the metadata chunk (things like 'CustomData|RoiMetadata_v1' or 'ImageMetadataLV'), and values that are associated metadata chunk.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def unstructured_metadata(\n    self,\n    *,\n    strip_prefix: bool = True,\n    include: set[str] | None = None,\n    exclude: set[str] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Exposes, and attempts to decode, each metadata chunk in the file.\n\n    !!! Tip \"new in version 0.4.3\"\n\n    This is provided as a *experimental* fallback in the event that\n    `ND2File.experiment` does not contain all of the information you need. No\n    attempt is made to parse or validate the metadata, and the format of various\n    sections, *may* change in future versions of nd2. Consumption of this metadata\n    should use appropriate exception handling!\n\n    The 'ImageMetadataLV' chunk is the most likely to contain useful information,\n    but if you're generally looking for \"hidden\" metadata, it may be helpful to\n    look at the full output.\n\n    Parameters\n    ----------\n    strip_prefix : bool, optional\n        Whether to strip the type information from the front of the keys in the\n        dict. For example, if `True`: `uiModeFQ` becomes `ModeFQ` and `bUsePFS`\n        becomes `UsePFS`, etc... by default `True`\n    include : set[str] | None, optional\n        If provided, only include the specified keys in the output. by default,\n        all metadata sections found in the file are included.\n    exclude : set[str] | None, optional\n        If provided, exclude the specified keys from the output. by default `None`\n\n    Returns\n    -------\n    dict[str, Any]\n        A dict of the unstructured metadata, with keys that are the type of the\n        metadata chunk (things like 'CustomData|RoiMetadata_v1' or\n        'ImageMetadataLV'), and values that are associated metadata chunk.\n    \"\"\"\n    return self._rdr.unstructured_metadata(strip_prefix, include, exclude)\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.unstructured_metadata(strip_prefix)","title":"<code>strip_prefix</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to strip the type information from the front of the keys in the dict. For example, if <code>True</code>: <code>uiModeFQ</code> becomes <code>ModeFQ</code> and <code>bUsePFS</code> becomes <code>UsePFS</code>, etc... by default <code>True</code></p>"},{"location":"reference/nd2/#nd2.ND2File.unstructured_metadata(include)","title":"<code>include</code>","text":"(<code>set[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only include the specified keys in the output. by default, all metadata sections found in the file are included.</p>"},{"location":"reference/nd2/#nd2.ND2File.unstructured_metadata(exclude)","title":"<code>exclude</code>","text":"(<code>set[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, exclude the specified keys from the output. by default <code>None</code></p>"},{"location":"reference/nd2/#nd2.ND2File.voxel_size","title":"voxel_size","text":"<pre><code>voxel_size(channel: int = 0) -&gt; VoxelSize\n</code></pre> <p>XYZ voxel size in microns.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>VoxelSize</code>           \u2013            <p>Named tuple with attrs <code>x</code>, <code>y</code>, and <code>z</code>.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def voxel_size(self, channel: int = 0) -&gt; _util.VoxelSize:\n    \"\"\"XYZ voxel size in microns.\n\n    Parameters\n    ----------\n    channel : int\n        Channel for which to retrieve voxel info, by default 0.\n        (Not yet implemented.)\n\n    Returns\n    -------\n    VoxelSize\n        Named tuple with attrs `x`, `y`, and `z`.\n    \"\"\"\n    return _util.VoxelSize(*self._rdr.voxel_size())\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.voxel_size(channel)","title":"<code>channel</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Channel for which to retrieve voxel info, by default 0. (Not yet implemented.)</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr","title":"write_ome_zarr","text":"<pre><code>write_ome_zarr(\n    dest: str | PathLike,\n    *,\n    chunk_shape: tuple[int, ...]\n    | Literal[\"auto\"]\n    | None = \"auto\",\n    shard_shape: tuple[int, ...] | None = None,\n    backend: ZarrBackend = \"auto\",\n    progress: bool = False,\n    position: int | None = None,\n    force_series: bool = False,\n    include_all_metadata: bool = True,\n    include_labels: bool = True,\n    version: Literal[\"0.5\"] = \"0.5\",\n    overwrite: bool = False,\n) -&gt; Path\n</code></pre> <p>Export to an OME-Zarr store.</p> <p>new in version 0.11.0</p> <p>Requires extras</p> <p>In order to use <code>write_ome_zarr</code> you must install <code>nd2</code> with an appropriate array-writing backend.  <code>zarr-python</code> is the reference implementation, but <code>tensorstore</code> is faster.</p> <ul> <li><code>pip install \"nd2[ome-zarr-tensorstore]\"</code> (to use tensorstore backend)</li> <li><code>pip install \"nd2[ome-zarr]\"</code> (to use zarr-python backend)</li> </ul> <p>Creates a Zarr v3 store with OME-NGFF 0.5 compliant metadata. Uses yaozarrs for metadata generation and either <code>zarr-python</code> or <code>tensorstore</code> for array writing.</p> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the created Zarr store.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If yaozarrs or the required backend library is not installed.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file contains unsupported data structures or invalid version.</p> </li> </ul> <p>Examples:</p> <p>Basic export:</p> <pre><code>&gt;&gt;&gt; import nd2\n&gt;&gt;&gt; with nd2.ND2File(\"experiment.nd2\") as f:\n...     f.write_ome_zarr(\"experiment.zarr\")\n</code></pre> <p>Export with specific chunking:</p> <pre><code>&gt;&gt;&gt; with nd2.ND2File(\"experiment.nd2\") as f:\n...     f.write_ome_zarr(\n...         \"experiment.zarr\",\n...         chunk_shape=(1, 1, 64, 256, 256),\n...     )\n</code></pre> <p>Export using tensorstore backend:</p> <pre><code>&gt;&gt;&gt; with nd2.ND2File(\"experiment.nd2\") as f:\n...     f.write_ome_zarr(\"experiment.zarr\", backend=\"tensorstore\")\n</code></pre> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def write_ome_zarr(\n    self,\n    dest: str | PathLike,\n    *,\n    chunk_shape: tuple[int, ...] | Literal[\"auto\"] | None = \"auto\",\n    shard_shape: tuple[int, ...] | None = None,\n    backend: ZarrBackend = \"auto\",\n    progress: bool = False,\n    position: int | None = None,\n    force_series: bool = False,\n    include_all_metadata: bool = True,\n    include_labels: bool = True,\n    version: Literal[\"0.5\"] = \"0.5\",\n    overwrite: bool = False,\n) -&gt; Path:\n    \"\"\"Export to an OME-Zarr store.\n\n    !!! Tip \"new in version 0.11.0\"\n\n    !!!important \"Requires extras\"\n        In order to use `write_ome_zarr` you must install `nd2` with an appropriate\n        array-writing backend.  `zarr-python` is the reference implementation,\n        but `tensorstore` is faster.\n\n        - `pip install \"nd2[ome-zarr-tensorstore]\"` (to use tensorstore backend)\n        - `pip install \"nd2[ome-zarr]\"` (to use zarr-python backend)\n\n    Creates a Zarr v3 store with OME-NGFF 0.5 compliant metadata.\n    Uses yaozarrs for metadata generation and either `zarr-python` or\n    `tensorstore` for array writing.\n\n    Parameters\n    ----------\n    dest : str | PathLike\n        Destination path for the Zarr store. Will be created as a directory.\n    chunk_shape : tuple[int, ...] | \"auto\" | None\n        Shape of chunks for the output array. If \"auto\" (default), determines\n        optimal chunking based on data size. If None, uses a single chunk.\n    shard_shape : tuple[int, ...] | None\n        Shape of shards for sharded storage. If provided, enables Zarr v3\n        sharding where each shard contains multiple chunks. Useful for\n        cloud storage to reduce number of objects.\n    backend : \"zarr\" | \"tensorstore\" | \"auto\"\n        Backend library to use for writing arrays.\n        - \"tensorstore\": Uses Google's tensorstore library\n        - \"zarr\": Uses zarr-python\n        - \"auto\": Tries to use tensorstore if installed, otherwise falls back\n        to zarr-python. Raises ImportError if neither is available.\n    progress : bool\n        Whether to display a progress bar during writing.\n    position : int | None\n        If the ND2 file contains multiple positions (XY stage positions),\n        export only this position index. If None, exports all positions\n        as separate groups within the store.\n    force_series : bool\n        If True, use bioformats2raw layout even for single position files.\n        This creates a store with OME/ directory and series metadata,\n        with the image in a \"0/\" subdirectory. Default is False.\n    include_all_metadata : bool\n        If True (default), *all* unstructured metadata chunks found in the ND2\n        will be included in the OME-Zarr metadata as JSON-encoded strings.\n        If False, only a minimal set of metadata will be included (those necessary\n        for the OME-NGFF specification, along with the OME-XML metadata if present).\n        Use `True` for maximum metadata retention, or `False` for a smaller store.\n    include_labels : bool\n        If True (default), export binary masks as OME-Zarr labels.\n        Binary masks from the ND2 file will be written to a \"labels\"\n        subdirectory within the image group. Each binary layer becomes\n        a separate label with its own name. Has no effect if the file\n        contains no binary data.\n    version : \"0.5\"\n        OME-NGFF specification version to use. Currently only \"0.5\" is\n        supported. This parameter is reserved for future use.\n    overwrite : bool\n        If True, overwrite the destination if it already exists.\n\n    Returns\n    -------\n    Path\n        Path to the created Zarr store.\n\n    Raises\n    ------\n    ImportError\n        If yaozarrs or the required backend library is not installed.\n    ValueError\n        If the file contains unsupported data structures or invalid version.\n\n    Examples\n    --------\n    Basic export:\n\n    &gt;&gt;&gt; import nd2\n    &gt;&gt;&gt; with nd2.ND2File(\"experiment.nd2\") as f:\n    ...     f.write_ome_zarr(\"experiment.zarr\")\n\n    Export with specific chunking:\n\n    &gt;&gt;&gt; with nd2.ND2File(\"experiment.nd2\") as f:\n    ...     f.write_ome_zarr(\n    ...         \"experiment.zarr\",\n    ...         chunk_shape=(1, 1, 64, 256, 256),\n    ...     )\n\n    Export using tensorstore backend:\n\n    &gt;&gt;&gt; with nd2.ND2File(\"experiment.nd2\") as f:\n    ...     f.write_ome_zarr(\"experiment.zarr\", backend=\"tensorstore\")\n    \"\"\"\n    from ._ome_zarr import nd2_to_ome_zarr\n\n    return nd2_to_ome_zarr(\n        self,\n        dest,\n        chunk_shape=chunk_shape,\n        shard_shape=shard_shape,\n        backend=backend,\n        progress=progress,\n        position=position,\n        force_series=force_series,\n        include_all_metadata=include_all_metadata,\n        include_labels=include_labels,\n        version=version,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the Zarr store. Will be created as a directory.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Shape of chunks for the output array. If \"auto\" (default), determines optimal chunking based on data size. If None, uses a single chunk.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(shard_shape)","title":"<code>shard_shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shape of shards for sharded storage. If provided, enables Zarr v3 sharding where each shard contains multiple chunks. Useful for cloud storage to reduce number of objects.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(backend)","title":"<code>backend</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto'</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend library to use for writing arrays. - \"tensorstore\": Uses Google's tensorstore library - \"zarr\": Uses zarr-python - \"auto\": Tries to use tensorstore if installed, otherwise falls back to zarr-python. Raises ImportError if neither is available.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display a progress bar during writing.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(position)","title":"<code>position</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If the ND2 file contains multiple positions (XY stage positions), export only this position index. If None, exports all positions as separate groups within the store.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(force_series)","title":"<code>force_series</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use bioformats2raw layout even for single position files. This creates a store with OME/ directory and series metadata, with the image in a \"0/\" subdirectory. Default is False.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(include_all_metadata)","title":"<code>include_all_metadata</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), all unstructured metadata chunks found in the ND2 will be included in the OME-Zarr metadata as JSON-encoded strings. If False, only a minimal set of metadata will be included (those necessary for the OME-NGFF specification, along with the OME-XML metadata if present). Use <code>True</code> for maximum metadata retention, or <code>False</code> for a smaller store.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(include_labels)","title":"<code>include_labels</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), export binary masks as OME-Zarr labels. Binary masks from the ND2 file will be written to a \"labels\" subdirectory within the image group. Each binary layer becomes a separate label with its own name. Has no effect if the file contains no binary data.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(version)","title":"<code>version</code>","text":"(<code>'0.5'</code>, default:                   <code>'0.5'</code> )           \u2013            <p>OME-NGFF specification version to use. Currently only \"0.5\" is supported. This parameter is reserved for future use.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_ome_zarr(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite the destination if it already exists.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_tiff","title":"write_tiff","text":"<pre><code>write_tiff(\n    dest: str | PathLike,\n    *,\n    include_unstructured_metadata: bool = True,\n    progress: bool = False,\n    on_frame: Callable[[int, int, dict[str, int]], None]\n    | None\n    | None = None,\n    modify_ome: Callable[[OME], None] | None = None,\n) -&gt; None\n</code></pre> <p>Export to an (OME)-TIFF file.</p> <p>new in version 0.10.0</p> <p>To include OME-XML metadata, use extension <code>.ome.tif</code> or <code>.ome.tiff</code>.</p> <p>Parameters:</p> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def write_tiff(\n    self,\n    dest: str | PathLike,\n    *,\n    include_unstructured_metadata: bool = True,\n    progress: bool = False,\n    on_frame: Callable[[int, int, dict[str, int]], None] | None | None = None,\n    modify_ome: Callable[[ome_types.OME], None] | None = None,\n) -&gt; None:\n    \"\"\"Export to an (OME)-TIFF file.\n\n    !!! Tip \"new in version 0.10.0\"\n\n    To include OME-XML metadata, use extension `.ome.tif` or `.ome.tiff`.\n\n    Parameters\n    ----------\n    dest : str  | PathLike\n        The destination TIFF file.\n    include_unstructured_metadata :  bool\n        Whether to include unstructured metadata in the OME-XML.\n        This includes all of the metadata that we can find in the ND2 file in the\n        StructuredAnnotations section of the OME-XML (as mapping of\n        metadata chunk name to JSON-encoded string). By default `True`.\n    progress : bool\n        Whether to display progress bar.  If `True` and `tqdm` is installed, it will\n        be used. Otherwise, a simple text counter will be printed to the console.\n        By default `False`.\n    on_frame : Callable[[int, int, dict[str, int]], None] | None\n        A function to call after each frame is written. The function should accept\n        three arguments: the current frame number, the total number of frames, and\n        a dictionary of the current frame's indices (e.g. `{\"T\": 0, \"Z\": 1}`)\n        (Useful for integrating custom progress bars or logging.)\n    modify_ome : Callable[[ome_types.OME], None]\n        A function to modify the OME metadata before writing it to the file.\n        Accepts an `ome_types.OME` object and should modify it in place.\n        (reminder: OME-XML is only written if the file extension is `.ome.tif` or\n        `.ome.tiff`)\n    \"\"\"\n    from .tiff import nd2_to_tiff\n\n    return nd2_to_tiff(\n        self,\n        dest,\n        include_unstructured_metadata=include_unstructured_metadata,\n        progress=progress,\n        on_frame=on_frame,\n        modify_ome=modify_ome,\n    )\n</code></pre>"},{"location":"reference/nd2/#nd2.ND2File.write_tiff(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>The destination TIFF file.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_tiff(include_unstructured_metadata)","title":"<code>include_unstructured_metadata</code>","text":"(<code> bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include unstructured metadata in the OME-XML. This includes all of the metadata that we can find in the ND2 file in the StructuredAnnotations section of the OME-XML (as mapping of metadata chunk name to JSON-encoded string). By default <code>True</code>.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_tiff(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display progress bar.  If <code>True</code> and <code>tqdm</code> is installed, it will be used. Otherwise, a simple text counter will be printed to the console. By default <code>False</code>.</p>"},{"location":"reference/nd2/#nd2.ND2File.write_tiff(on_frame)","title":"<code>on_frame</code>","text":"(<code>Callable[[int, int, dict[str, int]], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>A function to call after each frame is written. The function should accept three arguments: the current frame number, the total number of frames, and a dictionary of the current frame's indices (e.g. <code>{\"T\": 0, \"Z\": 1}</code>) (Useful for integrating custom progress bars or logging.)</p>"},{"location":"reference/nd2/#nd2.ND2File.write_tiff(modify_ome)","title":"<code>modify_ome</code>","text":"(<code>Callable[[OME], None]</code>, default:                   <code>None</code> )           \u2013            <p>A function to modify the OME metadata before writing it to the file. Accepts an <code>ome_types.OME</code> object and should modify it in place. (reminder: OME-XML is only written if the file extension is <code>.ome.tif</code> or <code>.ome.tiff</code>)</p>"},{"location":"reference/nd2/#nd2.imread","title":"imread","text":"<pre><code>imread(\n    file: Path | str,\n    *,\n    dask: Literal[False] = ...,\n    xarray: Literal[False] = ...,\n    validate_frames: bool = ...,\n) -&gt; ndarray\n</code></pre><pre><code>imread(\n    file: Path | str,\n    *,\n    dask: bool = ...,\n    xarray: Literal[True],\n    validate_frames: bool = ...,\n) -&gt; DataArray\n</code></pre><pre><code>imread(\n    file: Path | str,\n    *,\n    dask: Literal[True],\n    xarray: Literal[False] = ...,\n    validate_frames: bool = ...,\n) -&gt; Array\n</code></pre> <pre><code>imread(\n    file: Path | str,\n    *,\n    dask: bool = False,\n    xarray: bool = False,\n    validate_frames: bool = False,\n) -&gt; ndarray | DataArray | Array\n</code></pre> <p>Open <code>file</code>, return requested array type, and close <code>file</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[ndarray, Array, DataArray]</code>           \u2013            <p>Array subclass, depending on arguments used.</p> </li> </ul> Source code in <code>src/nd2/_nd2file.py</code> <pre><code>def imread(\n    file: Path | str,\n    *,\n    dask: bool = False,\n    xarray: bool = False,\n    validate_frames: bool = False,\n) -&gt; np.ndarray | xr.DataArray | dask.array.core.Array:\n    \"\"\"Open `file`, return requested array type, and close `file`.\n\n    Parameters\n    ----------\n    file : Path | str\n        Filepath (`str`) or `Path` object to ND2 file.\n    dask : bool\n        If `True`, returns a (delayed) `dask.array.Array`. This will avoid reading\n        any data from disk until specifically requested by using `.compute()` or\n        casting to a numpy array with `np.asarray()`. By default `False`.\n    xarray : bool\n        If `True`, returns an `xarray.DataArray`, `array.dims` will be populated\n        according to image metadata, and coordinates will be populated based on pixel\n        spacings. Additional metadata is available in `array.attrs['metadata']`.\n        If `dask` is also `True`, will return an xarray backed by a delayed dask array.\n        By default `False`.\n    validate_frames : bool\n        Whether to verify (and attempt to fix) frames whose positions have been\n        shifted relative to the predicted offset (i.e. in a corrupted file).\n        This comes at a slight performance penalty at file open, but may \"rescue\"\n        some corrupt files. by default False.\n\n    Returns\n    -------\n    Union[np.ndarray, dask.array.Array, xarray.DataArray]\n        Array subclass, depending on arguments used.\n    \"\"\"\n    with ND2File(file, validate_frames=validate_frames) as nd2:\n        if xarray:\n            return nd2.to_xarray(delayed=dask)\n        elif dask:\n            return nd2.to_dask()\n        else:\n            return nd2.asarray()\n</code></pre>"},{"location":"reference/nd2/#nd2.imread(file)","title":"<code>file</code>","text":"(<code>Path | str</code>)           \u2013            <p>Filepath (<code>str</code>) or <code>Path</code> object to ND2 file.</p>"},{"location":"reference/nd2/#nd2.imread(dask)","title":"<code>dask</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, returns a (delayed) <code>dask.array.Array</code>. This will avoid reading any data from disk until specifically requested by using <code>.compute()</code> or casting to a numpy array with <code>np.asarray()</code>. By default <code>False</code>.</p>"},{"location":"reference/nd2/#nd2.imread(xarray)","title":"<code>xarray</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, returns an <code>xarray.DataArray</code>, <code>array.dims</code> will be populated according to image metadata, and coordinates will be populated based on pixel spacings. Additional metadata is available in <code>array.attrs['metadata']</code>. If <code>dask</code> is also <code>True</code>, will return an xarray backed by a delayed dask array. By default <code>False</code>.</p>"},{"location":"reference/nd2/#nd2.imread(validate_frames)","title":"<code>validate_frames</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to verify (and attempt to fix) frames whose positions have been shifted relative to the predicted offset (i.e. in a corrupted file). This comes at a slight performance penalty at file open, but may \"rescue\" some corrupt files. by default False.</p>"},{"location":"reference/nd2/#nd2.is_legacy","title":"is_legacy","text":"<pre><code>is_legacy(path: StrOrPath) -&gt; bool\n</code></pre> <p>Return <code>True</code> if <code>path</code> is a legacy ND2 file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the file is a legacy ND2 file.</p> </li> </ul> Source code in <code>src/nd2/_util.py</code> <pre><code>def is_legacy(path: StrOrPath) -&gt; bool:\n    \"\"\"Return `True` if `path` is a legacy ND2 file.\n\n    Parameters\n    ----------\n    path : Union[str, bytes, PathLike]\n        A path to query\n\n    Returns\n    -------\n    bool\n        Whether the file is a legacy ND2 file.\n    \"\"\"\n    with open(path, \"rb\") as fh:\n        return fh.read(4) == OLD_HEADER_MAGIC\n</code></pre>"},{"location":"reference/nd2/#nd2.is_legacy(path)","title":"<code>path</code>","text":"(<code>Union[str, bytes, PathLike]</code>)           \u2013            <p>A path to query</p>"},{"location":"reference/nd2/#nd2.is_supported_file","title":"is_supported_file","text":"<pre><code>is_supported_file(\n    path: FileOrBinaryIO,\n    open_: Callable[[StrOrPath], BinaryIO] = _open_binary,\n) -&gt; bool\n</code></pre> <p>Return <code>True</code> if <code>path</code> can be opened as an nd2 file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the can be opened.</p> </li> </ul> Source code in <code>src/nd2/_util.py</code> <pre><code>def is_supported_file(\n    path: FileOrBinaryIO,\n    open_: Callable[[StrOrPath], BinaryIO] = _open_binary,\n) -&gt; bool:\n    \"\"\"Return `True` if `path` can be opened as an nd2 file.\n\n    Parameters\n    ----------\n    path : Union[str, bytes, PathLike]\n        A path to query\n    open_ : Callable[[StrOrBytesPath, str], BinaryIO]\n        Filesystem opener, by default `builtins.open`\n\n    Returns\n    -------\n    bool\n        Whether the can be opened.\n    \"\"\"\n    if hasattr(path, \"read\"):\n        path = cast(\"BinaryIO\", path)\n        path.seek(0)\n        magic = path.read(4)\n    else:\n        with open_(path) as fh:\n            magic = fh.read(4)\n    return magic in (NEW_HEADER_MAGIC, OLD_HEADER_MAGIC)\n</code></pre>"},{"location":"reference/nd2/#nd2.is_supported_file(path)","title":"<code>path</code>","text":"(<code>Union[str, bytes, PathLike]</code>)           \u2013            <p>A path to query</p>"},{"location":"reference/nd2/#nd2.is_supported_file(open_)","title":"<code>open_</code>","text":"(<code>Callable[[StrOrBytesPath, str], BinaryIO]</code>, default:                   <code>_open_binary</code> )           \u2013            <p>Filesystem opener, by default <code>builtins.open</code></p>"},{"location":"reference/nd2/#nd2.nd2_to_tiff","title":"nd2_to_tiff","text":"<pre><code>nd2_to_tiff(\n    source: str | PathLike | ND2File,\n    dest: str | PathLike,\n    *,\n    include_unstructured_metadata: bool = True,\n    progress: bool = False,\n    on_frame: Callable[[int, int, dict[str, int]], None]\n    | None = None,\n    modify_ome: Callable[[OME], None] | None = None,\n) -&gt; None\n</code></pre> <p>Export an ND2 file to an (OME)-TIFF file.</p> <p>To include OME-XML metadata, use extension <code>.ome.tif</code> or <code>.ome.tiff</code>.</p> <p>https://docs.openmicroscopy.org/ome-model/6.3.1/ome-tiff/specification.html</p> <p>Parameters:</p> Source code in <code>src/nd2/tiff.py</code> <pre><code>def nd2_to_tiff(\n    source: str | PathLike | ND2File,\n    dest: str | PathLike,\n    *,\n    include_unstructured_metadata: bool = True,\n    progress: bool = False,\n    on_frame: Callable[[int, int, dict[str, int]], None] | None = None,\n    modify_ome: Callable[[ome_types.OME], None] | None = None,\n) -&gt; None:\n    \"\"\"Export an ND2 file to an (OME)-TIFF file.\n\n    To include OME-XML metadata, use extension `.ome.tif` or `.ome.tiff`.\n\n    &lt;https://docs.openmicroscopy.org/ome-model/6.3.1/ome-tiff/specification.html&gt;\n\n    Parameters\n    ----------\n    source : str | PathLike | ND2File\n        The ND2 file path or an open ND2File object.\n    dest : str  | PathLike\n        The destination TIFF file.\n    include_unstructured_metadata :  bool\n        Whether to include unstructured metadata in the OME-XML. This includes all of\n        the metadata that we can find in the ND2 file in the StructuredAnnotations\n        section of the OME-XML (as mapping of metadata chunk name to JSON-encoded\n        string). By default `True`.\n    progress : bool\n        Whether to display progress bar.  If `True` and `tqdm` is installed, it will\n        be used. Otherwise, a simple text counter will be printed to the console.\n        By default `False`.\n    on_frame : Callable[[int, int, dict[str, int]], None] | None\n        A function to call after each frame is written. The function should accept\n        three arguments: the current frame number, the total number of frames, and\n        a dictionary of the current frame's indices (e.g. `{\"T\": 0, \"Z\": 1}`)\n        (Useful for integrating custom progress bars or logging.)\n    modify_ome : Callable[[ome_types.OME], None]\n        A function to modify the OME metadata before writing it to the file.\n        Accepts an `ome_types.OME` object and should modify it in place.\n        (reminder: OME-XML is only written if the file extension is `.ome.tif` or\n        `.ome.tiff`)\n    \"\"\"\n    dest_path = Path(dest).expanduser().resolve()\n    output_ome = \".ome.\" in dest_path.name\n\n    # normalize source to an open ND2File, and remember if we opened it\n    close_when_done = False\n    if isinstance(source, (str, PathLike)):\n        from ._nd2file import ND2File\n\n        nd2f = ND2File(source)\n        close_when_done = True\n    else:\n        nd2f = source\n        if close_when_done := nd2f.closed:\n            nd2f.open()\n\n    try:\n        # map of axis_name -&gt; size\n        sizes = dict(nd2f.sizes)\n\n        # pop the number of positions from the sizes.\n        # The OME data model does best with 5D data, so we'll write multi-5D series\n        n_positions = sizes.pop(AXIS.POSITION, 1)\n\n        # join axis names as a string, and get shape of the data without positions\n        axes, shape = zip(*sizes.items())\n        # U (Unknown) -&gt; Q : other (OME)\n        metadata = {\"axes\": \"\".join(axes).upper().replace(AXIS.UNKNOWN, \"Q\")}\n\n        # Create OME-XML\n        ome_xml: bytes | None = None\n        if output_ome:\n            if nd2f.is_legacy:\n                warnings.warn(\n                    \"Cannot write OME metadata for legacy nd2 files.\"\n                    \"Please use a different file extension to avoid confusion\",\n                    stacklevel=2,\n                )\n            else:\n                # get the OME metadata object from the ND2File\n                ome = nd2_ome_metadata(\n                    nd2f,\n                    include_unstructured=include_unstructured_metadata,\n                    tiff_file_name=dest_path.name,\n                )\n                if modify_ome:\n                    # allow user to modify the OME metadata if they want\n                    modify_ome(ome)\n                ome_xml = ome.to_xml(exclude_unset=True).encode(\"utf-8\")\n\n        # total number of frames we will write\n        tot = nd2f._frame_count\n        # create a progress bar if requested\n        pbar = _pbar(total=tot, desc=f\"Exporting {nd2f.path}\") if progress else None\n\n        # `p_groups` will be a map of {position index -&gt; [(frame_number, f_index) ...]}\n        # where frame_number is passed to read_frame\n        # and f_index is a map of axis name to index (e.g. {\"T\": 0, \"Z\": 1})\n        # positions are grouped together so we can write them to the tiff file in order\n        p_groups: defaultdict[int, list[tuple[int, dict[str, int]]]] = defaultdict(list)\n        for f_num, f_index in enumerate(nd2f.loop_indices):\n            p_groups[f_index.get(AXIS.POSITION, 0)].append((f_num, f_index))\n\n        # create a function to iterate over all frames, updating pbar if requested\n        def position_iter(p: int) -&gt; Iterator[np.ndarray]:\n            \"\"\"Iterator over frames for a given position.\"\"\"\n            for f_num, f_index in p_groups[p]:\n                # call on_frame callback if provided\n                if on_frame is not None:\n                    on_frame(f_num, tot, f_index)\n\n                # yield the frame and update the progress bar\n                yield nd2f.read_frame(f_num)\n                if pbar is not None:\n                    pbar.set_description(repr(f_index))\n                    pbar.update()\n\n        # if we have ome_xml, we tell tifffile not to worry about it (ome=False)\n        tf_ome = False if ome_xml else None\n        # Write the tiff file\n        pixelsize = nd2f.voxel_size().x\n        photometric = tf.PHOTOMETRIC.RGB if nd2f.is_rgb else tf.PHOTOMETRIC.MINISBLACK\n        with tf.TiffWriter(dest_path, bigtiff=True, ome=tf_ome) as tif:\n            for p in range(n_positions):\n                tif.write(\n                    iter(position_iter(p)),\n                    shape=shape,\n                    dtype=nd2f.dtype,\n                    resolution=(1 / pixelsize, 1 / pixelsize),\n                    resolutionunit=tf.RESUNIT.MICROMETER,\n                    photometric=photometric,\n                    metadata=metadata,\n                    description=ome_xml,\n                )\n\n        if pbar is not None:\n            pbar.close()\n\n    finally:\n        # close the nd2 file if we opened it\n        if close_when_done:\n            nd2f.close()\n</code></pre>"},{"location":"reference/nd2/#nd2.nd2_to_tiff(source)","title":"<code>source</code>","text":"(<code>str | PathLike | ND2File</code>)           \u2013            <p>The ND2 file path or an open ND2File object.</p>"},{"location":"reference/nd2/#nd2.nd2_to_tiff(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>The destination TIFF file.</p>"},{"location":"reference/nd2/#nd2.nd2_to_tiff(include_unstructured_metadata)","title":"<code>include_unstructured_metadata</code>","text":"(<code> bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include unstructured metadata in the OME-XML. This includes all of the metadata that we can find in the ND2 file in the StructuredAnnotations section of the OME-XML (as mapping of metadata chunk name to JSON-encoded string). By default <code>True</code>.</p>"},{"location":"reference/nd2/#nd2.nd2_to_tiff(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display progress bar.  If <code>True</code> and <code>tqdm</code> is installed, it will be used. Otherwise, a simple text counter will be printed to the console. By default <code>False</code>.</p>"},{"location":"reference/nd2/#nd2.nd2_to_tiff(on_frame)","title":"<code>on_frame</code>","text":"(<code>Callable[[int, int, dict[str, int]], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>A function to call after each frame is written. The function should accept three arguments: the current frame number, the total number of frames, and a dictionary of the current frame's indices (e.g. <code>{\"T\": 0, \"Z\": 1}</code>) (Useful for integrating custom progress bars or logging.)</p>"},{"location":"reference/nd2/#nd2.nd2_to_tiff(modify_ome)","title":"<code>modify_ome</code>","text":"(<code>Callable[[OME], None]</code>, default:                   <code>None</code> )           \u2013            <p>A function to modify the OME metadata before writing it to the file. Accepts an <code>ome_types.OME</code> object and should modify it in place. (reminder: OME-XML is only written if the file extension is <code>.ome.tif</code> or <code>.ome.tiff</code>)</p>"},{"location":"reference/nd2/#nd2.rescue_nd2","title":"rescue_nd2","text":"<pre><code>rescue_nd2(\n    handle: BinaryIO | str,\n    frame_shape: tuple[int, ...] = (),\n    dtype: DTypeLike = \"uint16\",\n    max_iters: int | None = None,\n    verbose: bool = True,\n    chunk_start: bytes = _default_chunk_start,\n) -&gt; Iterator[ndarray]\n</code></pre> <p>Iterator that yields all discovered frames in a file handle.</p> <p>In nd2 files, each \"frame\" contains XY and all channel info (both true channels as well as RGB components).  Frames are laid out as (Y, X, C), and the <code>frame_shape</code> should match the expected frame size.  If <code>frame_shape</code> is not provided, a guess will be made about the vector shape of each frame, but it may be incorrect.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>each discovered frame in the file</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open('some_bad.nd2', 'rb') as fh:\n&gt;&gt;&gt;     frames = rescue_nd2(fh, (512, 512, 4), 'uint16')\n&gt;&gt;&gt;     ary = np.stack(frames)\n</code></pre> <p>You will likely want to reshape <code>ary</code> after that.</p> Source code in <code>src/nd2/_parse/_chunk_decode.py</code> <pre><code>def rescue_nd2(\n    handle: BinaryIO | str,\n    frame_shape: tuple[int, ...] = (),\n    dtype: DTypeLike = \"uint16\",\n    max_iters: int | None = None,\n    verbose: bool = True,\n    chunk_start: bytes = _default_chunk_start,\n) -&gt; Iterator[np.ndarray]:\n    \"\"\"Iterator that yields all discovered frames in a file handle.\n\n    In nd2 files, each \"frame\" contains XY and all channel info (both true\n    channels as well as RGB components).  Frames are laid out as (Y, X, C),\n    and the `frame_shape` should match the expected frame size.  If\n    `frame_shape` is not provided, a guess will be made about the vector shape\n    of each frame, but it may be incorrect.\n\n    Parameters\n    ----------\n    handle : BinaryIO | str\n        Filepath string, or binary file handle (For example\n        `handle = open('some.nd2', 'rb')`)\n    frame_shape : Tuple[int, ...], optional\n        expected shape of each frame, by default a 1 dimensional array will\n        be yielded for each frame, which can be reshaped later if desired.\n        NOTE: nd2 frames are generally ordered as\n        (height, width, true_channels, rgbcomponents).\n        So unlike numpy, which would use (channels, Y, X), you should use\n        (Y, X, channels)\n    dtype : np.dtype, optional\n        Data type, by default np.uint16\n    max_iters : Optional[int], optional\n        A maximum number of frames to yield, by default will yield until the\n        end of the file is reached\n    verbose : bool\n        whether to print info\n    chunk_start : bytes, optional\n        The bytes that start each chunk, by default 0x0ABECEDA.to_bytes(4, \"little\")\n\n    Yields\n    ------\n    np.ndarray\n        each discovered frame in the file\n\n    Examples\n    --------\n    &gt;&gt;&gt; with open('some_bad.nd2', 'rb') as fh:\n    &gt;&gt;&gt;     frames = rescue_nd2(fh, (512, 512, 4), 'uint16')\n    &gt;&gt;&gt;     ary = np.stack(frames)\n\n    You will likely want to reshape `ary` after that.\n    \"\"\"\n    dtype = np.dtype(dtype)\n    with ensure_handle(handle) as _fh:\n        mm = mmap.mmap(_fh.fileno(), 0, access=mmap.ACCESS_READ)\n\n        offset = 0\n        iters = 0\n        while True:\n            # search for the next part of the file starting with CHUNK_START\n            offset = mm.find(chunk_start, offset)\n            if offset &lt; 0:\n                if verbose:\n                    print(\"End of file.\")\n                return\n\n            # location at the end of the chunk header\n            end_hdr = offset + CHUNK_HEADER.size\n\n            # find the next \"!\"\n            # In nd2 files, each data chunk starts with the\n            # string \"ImageDataSeq|N\" ... where N is the frame index\n            next_bang = mm.find(b\"!\", end_hdr)\n            if next_bang &gt; 0 and (0 &lt; next_bang - end_hdr &lt; 128):\n                # if we find the \"!\"... make sure we have an ImageDataSeq\n                chunk_name = mm[end_hdr:next_bang]\n                if chunk_name.startswith(b\"ImageDataSeq|\"):\n                    if verbose:\n                        print(f\"Found image {iters} at offset {offset}\")\n                    # Now, read the actual data\n                    _, shift, length = CHUNK_HEADER.unpack(mm[offset:end_hdr])\n                    # convert to numpy array and yield\n                    # (can't remember why the extra 8 bytes)\n                    try:\n                        shape = frame_shape or ((length - 8) // dtype.itemsize,)\n                        yield np.ndarray(\n                            shape=shape,\n                            dtype=dtype,\n                            buffer=mm,\n                            offset=end_hdr + shift + 8,\n                        )\n                    except TypeError as e:  # pragma: no cover\n                        # buffer is likely too small\n                        if verbose:\n                            print(f\"Error at offset {offset}: {e}\")\n                    iters += 1\n            elif verbose:\n                print(f\"Found chunk at offset {offset} with no image data\")\n\n            offset += 1\n            if max_iters and iters &gt;= max_iters:\n                return\n</code></pre>"},{"location":"reference/nd2/#nd2.rescue_nd2(handle)","title":"<code>handle</code>","text":"(<code>BinaryIO | str</code>)           \u2013            <p>Filepath string, or binary file handle (For example <code>handle = open('some.nd2', 'rb')</code>)</p>"},{"location":"reference/nd2/#nd2.rescue_nd2(frame_shape)","title":"<code>frame_shape</code>","text":"(<code>Tuple[int, ...]</code>, default:                   <code>()</code> )           \u2013            <p>expected shape of each frame, by default a 1 dimensional array will be yielded for each frame, which can be reshaped later if desired. NOTE: nd2 frames are generally ordered as (height, width, true_channels, rgbcomponents). So unlike numpy, which would use (channels, Y, X), you should use (Y, X, channels)</p>"},{"location":"reference/nd2/#nd2.rescue_nd2(dtype)","title":"<code>dtype</code>","text":"(<code>dtype</code>, default:                   <code>'uint16'</code> )           \u2013            <p>Data type, by default np.uint16</p>"},{"location":"reference/nd2/#nd2.rescue_nd2(max_iters)","title":"<code>max_iters</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>A maximum number of frames to yield, by default will yield until the end of the file is reached</p>"},{"location":"reference/nd2/#nd2.rescue_nd2(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to print info</p>"},{"location":"reference/nd2/#nd2.rescue_nd2(chunk_start)","title":"<code>chunk_start</code>","text":"(<code>bytes</code>, default:                   <code>_default_chunk_start</code> )           \u2013            <p>The bytes that start each chunk, by default 0x0ABECEDA.to_bytes(4, \"little\")</p>"},{"location":"reference/nd2/index_py/","title":"index","text":""},{"location":"reference/nd2/index_py/#nd2.index","title":"nd2.index","text":"<p>Index ND2 files and print the results as a table.</p> <p>This module is intended to be used as a command-line utility. It will index the metadata of all ND2 files found in a folder and print the results as a table, or output as CSV or JSON.</p>"},{"location":"reference/nd2/index_py/#nd2.index--usage","title":"Usage","text":"<pre><code>python -m nd2.index [OPTIONS] paths [paths ...]\n</code></pre>"},{"location":"reference/nd2/index_py/#nd2.index--positional-arguments","title":"Positional Arguments","text":"Argument Description <code>paths</code> Path to an ND2 file or directory containing ND2 files."},{"location":"reference/nd2/index_py/#nd2.index--options","title":"Options","text":"Option Short Description <code>--help</code> <code>-h</code> Show this help message and exit. <code>--recurse</code> <code>-r</code> Recursively search directories. <code>--glob-pattern GLOB_PATTERN</code> <code>-g</code> Glob pattern to search for. <code>--sort-by COLUMN_NAME</code> <code>-s</code> Column to sort by. If not specified, the order is not guaranteed. To sort in reverse, append a hyphen (<code>-</code>). <code>--format</code> <code>{table,csv,json}</code> <code>-f</code> Output format: table, CSV, or JSON. <code>--include INCLUDE</code> <code>-i</code> Comma-separated columns to include in the output. <code>--exclude EXCLUDE</code> <code>-e</code> Comma-separated columns to exclude in the output. <code>--no-header</code> (none) Don't write the CSV header. <code>--filter FILTER</code> <code>-F</code> Filter the output using a Python expression (string) that evaluates to <code>True</code> or <code>False</code>. Evaluated in the context of each row. You can use any column name as a variable.Example: <code>\"acquired &gt; '2020' and kb &lt; 500\"</code>. (Can be used multiple times.)"},{"location":"reference/nd2/index_py/#nd2.index--example","title":"Example","text":"<pre><code>python -m nd2.index nd2/tests/data\n</code></pre> <p>When run on the test data used in testing this nd2 repo, the output looks like this:</p> <p></p> <p>Classes:</p> <ul> <li> <code>Record</code>           \u2013            <p>Dict returned by <code>index_file</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>index_file</code>             \u2013              <p>Return a dict with the index file data.</p> </li> <li> <code>index_files</code>             \u2013              <p>Return a list of <code>Record</code> dicts with the index file data.</p> </li> </ul>"},{"location":"reference/nd2/index_py/#nd2.index.Record","title":"Record","text":"<p>Dict returned by <code>index_file</code>.</p>"},{"location":"reference/nd2/index_py/#nd2.index.index_file","title":"index_file","text":"<pre><code>index_file(path: Path) -&gt; Record\n</code></pre> <p>Return a dict with the index file data.</p> Source code in <code>src/nd2/index.py</code> <pre><code>def index_file(path: Path) -&gt; Record:\n    \"\"\"Return a dict with the index file data.\"\"\"\n    with nd2.ND2File(path) as nd:\n        if nd.is_legacy:\n            software: dict = {}\n            acquired: datetime | None = None\n            binary = False\n        else:\n            rdr = cast(\"ModernReader\", nd._rdr)\n            software = rdr._app_info()\n            acquired = rdr._acquisition_datetime()\n            binary = nd.binary_data is not None\n\n        stat = path.stat()\n        exp = [(x.type, x.count) for x in nd.experiment]\n        axes, shape = zip(*nd.sizes.items())\n        if isinstance(acquired, datetime):\n            acq_str = acquired.strftime(TIME_FORMAT)\n        else:\n            acq_str = \"\"\n\n        return Record(\n            {\n                \"path\": str(path.resolve()),\n                \"name\": path.name,\n                \"version\": \".\".join(map(str, nd.version)),\n                \"kb\": round(stat.st_size / 1000, 2),\n                \"acquired\": acq_str,\n                \"experiment\": \";\".join([f\"{t}:{c}\" for t, c in exp]),\n                \"dtype\": str(nd.dtype),\n                \"shape\": list(shape),\n                \"axes\": \"\".join(axes),\n                \"binary\": binary,\n                \"rois\": False if nd.is_legacy else bool(nd.rois),\n                \"software_name\": software.get(\"SWNameString\", \"\"),\n                \"software_version\": software.get(\"VersionString\", \"\"),\n                \"grabber\": software.get(\"GrabberString\", \"\"),\n            }\n        )\n</code></pre>"},{"location":"reference/nd2/index_py/#nd2.index.index_files","title":"index_files","text":"<pre><code>index_files(\n    paths: Iterable[Path],\n    recurse: bool = False,\n    glob: str = \"*.nd2\",\n) -&gt; list[Record]\n</code></pre> <p>Return a list of <code>Record</code> dicts with the index file data.</p> Source code in <code>src/nd2/index.py</code> <pre><code>def index_files(\n    paths: Iterable[Path], recurse: bool = False, glob: str = \"*.nd2\"\n) -&gt; list[Record]:\n    \"\"\"Return a list of `Record` dicts with the index file data.\"\"\"\n    with ThreadPoolExecutor() as executor:\n        results = list(executor.map(index_file, _gather_files(paths, recurse, glob)))\n\n    return results\n</code></pre>"},{"location":"reference/nd2/index_py/#nd2.index.main","title":"main","text":"<pre><code>main(argv: Sequence[str] = ()) -&gt; None\n</code></pre> <p>Index ND2 files and print the results as a table.</p> Source code in <code>src/nd2/index.py</code> <pre><code>def main(argv: Sequence[str] = ()) -&gt; None:\n    \"\"\"Index ND2 files and print the results as a table.\"\"\"\n    args = _parse_args(argv)\n\n    data = index_files(paths=args.paths, recurse=args.recurse, glob=args.glob_pattern)\n    data = _filter_data(\n        data,\n        sort_by=args.sort_by,\n        include=args.include,\n        exclude=args.exclude,\n        filters=args.filter,\n    )\n\n    if args.format == \"table\":\n        _pretty_print_table(data, args.sort_by)\n    elif args.format == \"csv\":\n        _print_csv(data, args.no_header)\n    elif args.format == \"json\":\n        _print_json(data)\n</code></pre>"},{"location":"reference/nd2/jobs/","title":"jobs","text":""},{"location":"reference/nd2/jobs/#nd2.jobs","title":"nd2.jobs","text":"<p>JOBS support.</p> <p>Modules:</p> <ul> <li> <code>types</code>           \u2013            <p>TypedDict definitions for JOBS metadata schema.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/","title":"types","text":""},{"location":"reference/nd2/jobs/types/#nd2.jobs.types","title":"nd2.jobs.types","text":"<p>TypedDict definitions for JOBS metadata schema.</p> <p>This module provides type definitions for the JOBS workflow metadata found in ND2 files.</p> <p>The schema was inferred from analyzing 42 .bin job definition files and job metadata embedded in ND2 files.  It captures \"observed\" structures but may not be exhaustive.  All classes are guarded behind TYPE_CHECKING and MUST only be used for type hinting, not at runtime.</p> <p>Classes:</p> <ul> <li> <code>ActiveArea</code>           \u2013            <p>Active area within a well.</p> </li> <li> <code>CLxLayoutElement</code>           \u2013            <p>Layout element for well configuration.</p> </li> <li> <code>CLxWellplate</code>           \u2013            <p>Wellplate configuration.</p> </li> <li> <code>CustomDefinitions</code>           \u2013            <p>Custom definitions container.</p> </li> <li> <code>CustomWellplate</code>           \u2013            <p>Custom wellplate definition wrapper (inside CustomDefinitions).</p> </li> <li> <code>Custom_wellplate</code>           \u2013            <p>Top-level custom wellplate definition wrapper.</p> </li> <li> <code>Job</code>           \u2013            <p>Main job definition structure.</p> </li> <li> <code>JobProperty</code>           \u2013            <p>Job metadata properties.</p> </li> <li> <code>JobsDict</code>           \u2013            <p>Top-level JOBS metadata from ND2 files.</p> </li> <li> <code>LockableParamsWrapper</code>           \u2013            <p>Wrapper for lockable parameters.</p> </li> <li> <code>ParametersWrapper</code>           \u2013            <p>Wrapper for task parameters.</p> </li> <li> <code>ProgramDesc</code>           \u2013            <p>Program description metadata.</p> </li> <li> <code>ProgramParameters</code>           \u2013            <p>Program-level parameters.</p> </li> <li> <code>PropertyDefinitionItem</code>           \u2013            <p>A single property definition.</p> </li> <li> <code>ProtectedJob</code>           \u2013            <p>Encryption information for protected jobs.</p> </li> <li> <code>SLxShape</code>           \u2013            <p>Shape definition.</p> </li> <li> <code>SlotConnection</code>           \u2013            <p>Connection from one task's output to another's input.</p> </li> <li> <code>SlotConnectionsWrapper</code>           \u2013            <p>Wrapper for slot connections.</p> </li> <li> <code>Task</code>           \u2013            <p>JOBS workflow task structure.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>PropertyDefinitions</code>           \u2013            <p>Dictionary of property definitions, keyed by index (i0000000000, etc.).</p> </li> <li> <code>TasksDict</code>           \u2013            <p>Dictionary mapping user-provided task identifiers to task definitions.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitions","title":"PropertyDefinitions  <code>module-attribute</code>","text":"<pre><code>PropertyDefinitions = dict[str, 'PropertyDefinitionItem']\n</code></pre> <p>Dictionary of property definitions, keyed by index (i0000000000, etc.).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.TasksDict","title":"TasksDict  <code>module-attribute</code>","text":"<pre><code>TasksDict = dict[TaskName | str, 'Task']\n</code></pre> <p>Dictionary mapping user-provided task identifiers to task definitions.</p> <p>The keys are arbitrary user-provided identifiers (like variable names in a workflow). The values are Task objects with a common structure defined in nd2.jobs._tasks.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ActiveArea","title":"ActiveArea","text":"<p>Active area within a well.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxLayoutElement","title":"CLxLayoutElement","text":"<p>Layout element for well configuration.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate","title":"CLxWellplate","text":"<p>Wellplate configuration.</p> <p>Defines the geometry and naming of a wellplate.</p> <p>Attributes:</p> <ul> <li> <code>CLxLayoutElement</code>               (<code>CLxLayoutElement</code>)           \u2013            <p>Layout element defining well active area.</p> </li> <li> <code>ColsAscending</code>               (<code>bool</code>)           \u2013            <p>Whether columns are numbered ascending.</p> </li> <li> <code>CompanyName</code>               (<code>Required[str]</code>)           \u2013            <p>Company/manufacturer name.</p> </li> <li> <code>ModelName</code>               (<code>Required[str]</code>)           \u2013            <p>Model name of the wellplate.</p> </li> <li> <code>NamingMode</code>               (<code>Required[int]</code>)           \u2013            <p>Naming mode for wells.</p> </li> <li> <code>RowsAscending</code>               (<code>bool</code>)           \u2013            <p>Whether rows are numbered ascending.</p> </li> <li> <code>SLxShape</code>               (<code>SLxShape</code>)           \u2013            <p>Shape defining overall plate bounds.</p> </li> <li> <code>TypeName</code>               (<code>Required[str]</code>)           \u2013            <p>Type name (may be empty).</p> </li> <li> <code>Uuid</code>               (<code>Required[str]</code>)           \u2013            <p>Unique identifier for this wellplate definition.</p> </li> <li> <code>XCount</code>               (<code>Required[int]</code>)           \u2013            <p>Number of columns.</p> </li> <li> <code>XDistance</code>               (<code>Required[float]</code>)           \u2013            <p>Distance between well centers in X (micrometers).</p> </li> <li> <code>XNamingType</code>               (<code>Required[int]</code>)           \u2013            <p>Column naming type (0=numeric, 1=alphabetic).</p> </li> <li> <code>XWellOffset</code>               (<code>Required[float]</code>)           \u2013            <p>X offset to first well center in micrometers.</p> </li> <li> <code>YCount</code>               (<code>Required[int]</code>)           \u2013            <p>Number of rows.</p> </li> <li> <code>YDistance</code>               (<code>Required[float]</code>)           \u2013            <p>Distance between well centers in Y (micrometers).</p> </li> <li> <code>YNamingType</code>               (<code>Required[int]</code>)           \u2013            <p>Row naming type (0=numeric, 1=alphabetic).</p> </li> <li> <code>YWellOffset</code>               (<code>Required[float]</code>)           \u2013            <p>Y offset to first well center in micrometers.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.CLxLayoutElement","title":"CLxLayoutElement  <code>instance-attribute</code>","text":"<pre><code>CLxLayoutElement: CLxLayoutElement\n</code></pre> <p>Layout element defining well active area.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.ColsAscending","title":"ColsAscending  <code>instance-attribute</code>","text":"<pre><code>ColsAscending: bool\n</code></pre> <p>Whether columns are numbered ascending.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.CompanyName","title":"CompanyName  <code>instance-attribute</code>","text":"<pre><code>CompanyName: Required[str]\n</code></pre> <p>Company/manufacturer name.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.ModelName","title":"ModelName  <code>instance-attribute</code>","text":"<pre><code>ModelName: Required[str]\n</code></pre> <p>Model name of the wellplate.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.NamingMode","title":"NamingMode  <code>instance-attribute</code>","text":"<pre><code>NamingMode: Required[int]\n</code></pre> <p>Naming mode for wells.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.RowsAscending","title":"RowsAscending  <code>instance-attribute</code>","text":"<pre><code>RowsAscending: bool\n</code></pre> <p>Whether rows are numbered ascending.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.SLxShape","title":"SLxShape  <code>instance-attribute</code>","text":"<pre><code>SLxShape: SLxShape\n</code></pre> <p>Shape defining overall plate bounds.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.TypeName","title":"TypeName  <code>instance-attribute</code>","text":"<pre><code>TypeName: Required[str]\n</code></pre> <p>Type name (may be empty).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.Uuid","title":"Uuid  <code>instance-attribute</code>","text":"<pre><code>Uuid: Required[str]\n</code></pre> <p>Unique identifier for this wellplate definition.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.XCount","title":"XCount  <code>instance-attribute</code>","text":"<pre><code>XCount: Required[int]\n</code></pre> <p>Number of columns.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.XDistance","title":"XDistance  <code>instance-attribute</code>","text":"<pre><code>XDistance: Required[float]\n</code></pre> <p>Distance between well centers in X (micrometers).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.XNamingType","title":"XNamingType  <code>instance-attribute</code>","text":"<pre><code>XNamingType: Required[int]\n</code></pre> <p>Column naming type (0=numeric, 1=alphabetic).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.XWellOffset","title":"XWellOffset  <code>instance-attribute</code>","text":"<pre><code>XWellOffset: Required[float]\n</code></pre> <p>X offset to first well center in micrometers.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.YCount","title":"YCount  <code>instance-attribute</code>","text":"<pre><code>YCount: Required[int]\n</code></pre> <p>Number of rows.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.YDistance","title":"YDistance  <code>instance-attribute</code>","text":"<pre><code>YDistance: Required[float]\n</code></pre> <p>Distance between well centers in Y (micrometers).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.YNamingType","title":"YNamingType  <code>instance-attribute</code>","text":"<pre><code>YNamingType: Required[int]\n</code></pre> <p>Row naming type (0=numeric, 1=alphabetic).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CLxWellplate.YWellOffset","title":"YWellOffset  <code>instance-attribute</code>","text":"<pre><code>YWellOffset: Required[float]\n</code></pre> <p>Y offset to first well center in micrometers.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CustomDefinitions","title":"CustomDefinitions","text":"<p>Custom definitions container.</p> <p>Contains custom configurations like wellplate definitions.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.CustomWellplate","title":"CustomWellplate","text":"<p>Custom wellplate definition wrapper (inside CustomDefinitions).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Custom_wellplate","title":"Custom_wellplate","text":"<p>Top-level custom wellplate definition wrapper.</p> <p>This appears at the top level in standalone .bin files, separate from the Job structure.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Job","title":"Job","text":"<p>Main job definition structure.</p> <p>This is the core structure that defines a JOBS workflow. It appears both in ND2 files (inside JobsDict) and in standalone .bin job definition files.</p> <p>Attributes:</p> <ul> <li> <code>CustomDefinitions</code>               (<code>CustomDefinitions</code>)           \u2013            <p>Custom definitions like wellplate configurations.</p> </li> <li> <code>ProgramParameters</code>               (<code>ProgramParameters</code>)           \u2013            <p>Program-level parameters.</p> </li> <li> <code>Property</code>               (<code>JobProperty</code>)           \u2013            <p>Job metadata like name and description.</p> </li> <li> <code>PropertyDefinitions</code>               (<code>PropertyDefinitions</code>)           \u2013            <p>User-configurable property definitions.</p> </li> <li> <code>Tasks</code>               (<code>TasksDict</code>)           \u2013            <p>Dictionary mapping task names to task definitions.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Job.CustomDefinitions","title":"CustomDefinitions  <code>instance-attribute</code>","text":"<pre><code>CustomDefinitions: CustomDefinitions\n</code></pre> <p>Custom definitions like wellplate configurations.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Job.ProgramParameters","title":"ProgramParameters  <code>instance-attribute</code>","text":"<pre><code>ProgramParameters: ProgramParameters\n</code></pre> <p>Program-level parameters.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Job.Property","title":"Property  <code>instance-attribute</code>","text":"<pre><code>Property: JobProperty\n</code></pre> <p>Job metadata like name and description.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Job.PropertyDefinitions","title":"PropertyDefinitions  <code>instance-attribute</code>","text":"<pre><code>PropertyDefinitions: PropertyDefinitions\n</code></pre> <p>User-configurable property definitions.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Job.Tasks","title":"Tasks  <code>instance-attribute</code>","text":"<pre><code>Tasks: TasksDict\n</code></pre> <p>Dictionary mapping task names to task definitions.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty","title":"JobProperty","text":"<p>Job metadata properties.</p> <p>Attributes:</p> <ul> <li> <code>Desc</code>               (<code>Required[str]</code>)           \u2013            <p>Description of the job.</p> </li> <li> <code>Name</code>               (<code>Required[str]</code>)           \u2013            <p>Name of the job.</p> </li> <li> <code>ProgressProperties</code>               (<code>int</code>)           \u2013            <p>Progress properties version 1.</p> </li> <li> <code>ProgressProperties_v2</code>               (<code>int</code>)           \u2013            <p>Progress properties version 2.</p> </li> <li> <code>State</code>               (<code>Required[int]</code>)           \u2013            <p>Job state flag.</p> </li> <li> <code>Usability</code>               (<code>Required[list[int]]</code>)           \u2013            <p>Usability flags.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty.Desc","title":"Desc  <code>instance-attribute</code>","text":"<pre><code>Desc: Required[str]\n</code></pre> <p>Description of the job.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty.Name","title":"Name  <code>instance-attribute</code>","text":"<pre><code>Name: Required[str]\n</code></pre> <p>Name of the job.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty.ProgressProperties","title":"ProgressProperties  <code>instance-attribute</code>","text":"<pre><code>ProgressProperties: int\n</code></pre> <p>Progress properties version 1.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty.ProgressProperties_v2","title":"ProgressProperties_v2  <code>instance-attribute</code>","text":"<pre><code>ProgressProperties_v2: int\n</code></pre> <p>Progress properties version 2.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty.State","title":"State  <code>instance-attribute</code>","text":"<pre><code>State: Required[int]\n</code></pre> <p>Job state flag.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobProperty.Usability","title":"Usability  <code>instance-attribute</code>","text":"<pre><code>Usability: Required[list[int]]\n</code></pre> <p>Usability flags.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobsDict","title":"JobsDict","text":"<p>Top-level JOBS metadata from ND2 files.</p> <p>This is what <code>ND2File.jobs</code> returns. It wraps the Job definition with additional runtime metadata.</p> <p>Attributes:</p> <ul> <li> <code>Custom_wellplate</code>               (<code>NotRequired[Custom_wellplate]</code>)           \u2013            <p>Custom wellplate definition at top level (for standalone .bin files).</p> </li> <li> <code>Job</code>               (<code>Job | None</code>)           \u2013            <p>The actual job definition.  None if ProtectedJob is present.</p> </li> <li> <code>JobRunGUID</code>               (<code>str</code>)           \u2013            <p>Unique identifier for this specific job run.</p> </li> <li> <code>ProgramDesc</code>               (<code>NotRequired[ProgramDesc]</code>)           \u2013            <p>Program description metadata.</p> </li> <li> <code>ProtectedJob</code>               (<code>ProtectedJob | None</code>)           \u2013            <p>Encryption info if job is protected, None otherwise.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobsDict.Custom_wellplate","title":"Custom_wellplate  <code>instance-attribute</code>","text":"<pre><code>Custom_wellplate: NotRequired[Custom_wellplate]\n</code></pre> <p>Custom wellplate definition at top level (for standalone .bin files).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobsDict.Job","title":"Job  <code>instance-attribute</code>","text":"<pre><code>Job: Job | None\n</code></pre> <p>The actual job definition.  None if ProtectedJob is present.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobsDict.JobRunGUID","title":"JobRunGUID  <code>instance-attribute</code>","text":"<pre><code>JobRunGUID: str\n</code></pre> <p>Unique identifier for this specific job run.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobsDict.ProgramDesc","title":"ProgramDesc  <code>instance-attribute</code>","text":"<pre><code>ProgramDesc: NotRequired[ProgramDesc]\n</code></pre> <p>Program description metadata.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.JobsDict.ProtectedJob","title":"ProtectedJob  <code>instance-attribute</code>","text":"<pre><code>ProtectedJob: ProtectedJob | None\n</code></pre> <p>Encryption info if job is protected, None otherwise.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.LockableParamsWrapper","title":"LockableParamsWrapper","text":"<p>Wrapper for lockable parameters.</p> <p>Attributes:</p> <ul> <li> <code>LockableParams</code>               (<code>dict[LockableParamName, bool]</code>)           \u2013            <p>Dictionary mapping parameter names to locked state.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.LockableParamsWrapper.LockableParams","title":"LockableParams  <code>instance-attribute</code>","text":"<pre><code>LockableParams: dict[LockableParamName, bool]\n</code></pre> <p>Dictionary mapping parameter names to locked state.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ParametersWrapper","title":"ParametersWrapper","text":"<p>Wrapper for task parameters.</p> <p>Attributes:</p> <ul> <li> <code>Parameters</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Task-specific parameters structure.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ParametersWrapper.Parameters","title":"Parameters  <code>instance-attribute</code>","text":"<pre><code>Parameters: dict[str, Any]\n</code></pre> <p>Task-specific parameters structure.</p> <p>Keys are 'Parameter0', 'Parameter1', etc., each mapping to a Parameter dict.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProgramDesc","title":"ProgramDesc","text":"<p>Program description metadata.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProgramParameters","title":"ProgramParameters","text":"<p>Program-level parameters.</p> <p>Attributes:</p> <ul> <li> <code>Properties</code>               (<code>dict[str, Any] | list[Any]</code>)           \u2013            <p>Additional properties.</p> </li> <li> <code>Summary</code>               (<code>str</code>)           \u2013            <p>Summary text for the program.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProgramParameters.Properties","title":"Properties  <code>instance-attribute</code>","text":"<pre><code>Properties: dict[str, Any] | list[Any]\n</code></pre> <p>Additional properties.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProgramParameters.Summary","title":"Summary  <code>instance-attribute</code>","text":"<pre><code>Summary: str\n</code></pre> <p>Summary text for the program.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem","title":"PropertyDefinitionItem","text":"<p>A single property definition.</p> <p>Defines a user-configurable parameter for the job.</p> <p>Attributes:</p> <ul> <li> <code>DependencyExpression</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Expression for conditional visibility.</p> </li> <li> <code>Flags</code>               (<code>int</code>)           \u2013            <p>Additional flags.</p> </li> <li> <code>Key</code>               (<code>Required[str]</code>)           \u2013            <p>Property name/key.</p> </li> <li> <code>Type</code>               (<code>Required[int]</code>)           \u2013            <p>Property type.</p> </li> <li> <code>Value</code>               (<code>Required[float]</code>)           \u2013            <p>Current value.</p> </li> <li> <code>Value1Desc</code>               (<code>str</code>)           \u2013            <p>Description for value 1 (e.g., 'Yes').</p> </li> <li> <code>Value2Desc</code>               (<code>str</code>)           \u2013            <p>Description for value 2 (e.g., 'No').</p> </li> <li> <code>Value3Desc</code>               (<code>str</code>)           \u2013            <p>Description for value 3.</p> </li> <li> <code>Value4Desc</code>               (<code>str</code>)           \u2013            <p>Description for value 4.</p> </li> <li> <code>Visibility</code>               (<code>Required[int]</code>)           \u2013            <p>Visibility flag.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.DependencyExpression","title":"DependencyExpression  <code>instance-attribute</code>","text":"<pre><code>DependencyExpression: dict[str, Any]\n</code></pre> <p>Expression for conditional visibility.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Flags","title":"Flags  <code>instance-attribute</code>","text":"<pre><code>Flags: int\n</code></pre> <p>Additional flags.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Key","title":"Key  <code>instance-attribute</code>","text":"<pre><code>Key: Required[str]\n</code></pre> <p>Property name/key.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Type","title":"Type  <code>instance-attribute</code>","text":"<pre><code>Type: Required[int]\n</code></pre> <p>Property type.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Value","title":"Value  <code>instance-attribute</code>","text":"<pre><code>Value: Required[float]\n</code></pre> <p>Current value.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Value1Desc","title":"Value1Desc  <code>instance-attribute</code>","text":"<pre><code>Value1Desc: str\n</code></pre> <p>Description for value 1 (e.g., 'Yes').</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Value2Desc","title":"Value2Desc  <code>instance-attribute</code>","text":"<pre><code>Value2Desc: str\n</code></pre> <p>Description for value 2 (e.g., 'No').</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Value3Desc","title":"Value3Desc  <code>instance-attribute</code>","text":"<pre><code>Value3Desc: str\n</code></pre> <p>Description for value 3.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Value4Desc","title":"Value4Desc  <code>instance-attribute</code>","text":"<pre><code>Value4Desc: str\n</code></pre> <p>Description for value 4.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.PropertyDefinitionItem.Visibility","title":"Visibility  <code>instance-attribute</code>","text":"<pre><code>Visibility: Required[int]\n</code></pre> <p>Visibility flag.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProtectedJob","title":"ProtectedJob","text":"<p>Encryption information for protected jobs.</p> <p>Attributes:</p> <ul> <li> <code>Data</code>               (<code>str</code>)           \u2013            <p>Encrypted job data as a base64 data URI string.</p> </li> <li> <code>DataSize</code>               (<code>Required[int]</code>)           \u2013            <p>Size of the encrypted data in bytes.</p> </li> <li> <code>EncryptionType</code>               (<code>Required[int]</code>)           \u2013            <p>Encryption algorithm identifier (e.g., 1).</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProtectedJob.Data","title":"Data  <code>instance-attribute</code>","text":"<pre><code>Data: str\n</code></pre> <p>Encrypted job data as a base64 data URI string.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProtectedJob.DataSize","title":"DataSize  <code>instance-attribute</code>","text":"<pre><code>DataSize: Required[int]\n</code></pre> <p>Size of the encrypted data in bytes.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.ProtectedJob.EncryptionType","title":"EncryptionType  <code>instance-attribute</code>","text":"<pre><code>EncryptionType: Required[int]\n</code></pre> <p>Encryption algorithm identifier (e.g., 1).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape","title":"SLxShape","text":"<p>Shape definition.</p> <p>Can represent either a circle (Type=1) or rectangle (Type=2).</p> <p>Attributes:</p> <ul> <li> <code>CenterX</code>               (<code>float</code>)           \u2013            <p>Center X coordinate (for circular shapes).</p> </li> <li> <code>CenterY</code>               (<code>float</code>)           \u2013            <p>Center Y coordinate (for circular shapes).</p> </li> <li> <code>Radius</code>               (<code>float</code>)           \u2013            <p>Radius in micrometers (for circular shapes).</p> </li> <li> <code>RectB</code>               (<code>float</code>)           \u2013            <p>Bottom edge in micrometers (for rectangular shapes).</p> </li> <li> <code>RectL</code>               (<code>float</code>)           \u2013            <p>Left edge in micrometers (for rectangular shapes).</p> </li> <li> <code>RectR</code>               (<code>float</code>)           \u2013            <p>Right edge in micrometers (for rectangular shapes).</p> </li> <li> <code>RectT</code>               (<code>float</code>)           \u2013            <p>Top edge in micrometers (for rectangular shapes).</p> </li> <li> <code>Type</code>               (<code>Required[int]</code>)           \u2013            <p>Shape type: 1=circle, 2=rectangle.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.CenterX","title":"CenterX  <code>instance-attribute</code>","text":"<pre><code>CenterX: float\n</code></pre> <p>Center X coordinate (for circular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.CenterY","title":"CenterY  <code>instance-attribute</code>","text":"<pre><code>CenterY: float\n</code></pre> <p>Center Y coordinate (for circular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.Radius","title":"Radius  <code>instance-attribute</code>","text":"<pre><code>Radius: float\n</code></pre> <p>Radius in micrometers (for circular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.RectB","title":"RectB  <code>instance-attribute</code>","text":"<pre><code>RectB: float\n</code></pre> <p>Bottom edge in micrometers (for rectangular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.RectL","title":"RectL  <code>instance-attribute</code>","text":"<pre><code>RectL: float\n</code></pre> <p>Left edge in micrometers (for rectangular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.RectR","title":"RectR  <code>instance-attribute</code>","text":"<pre><code>RectR: float\n</code></pre> <p>Right edge in micrometers (for rectangular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.RectT","title":"RectT  <code>instance-attribute</code>","text":"<pre><code>RectT: float\n</code></pre> <p>Top edge in micrometers (for rectangular shapes).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SLxShape.Type","title":"Type  <code>instance-attribute</code>","text":"<pre><code>Type: Required[int]\n</code></pre> <p>Shape type: 1=circle, 2=rectangle.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SlotConnection","title":"SlotConnection","text":"<p>Connection from one task's output to another's input.</p> <p>Attributes:</p> <ul> <li> <code>ParameterName</code>               (<code>str</code>)           \u2013            <p>Name of the parameter being connected (e.g., 'Plate.Wellplate').</p> </li> <li> <code>ParameterType</code>               (<code>int</code>)           \u2013            <p>Type of the parameter. Usually just 0 or 1.</p> </li> <li> <code>SlotType</code>               (<code>int</code>)           \u2013            <p>Type identifier for the slot.  Likely a bit flag enum.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SlotConnection.ParameterName","title":"ParameterName  <code>instance-attribute</code>","text":"<pre><code>ParameterName: str\n</code></pre> <p>Name of the parameter being connected (e.g., 'Plate.Wellplate').</p> <p>Likely follow a TaskName.PropertyPath pattern.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SlotConnection.ParameterType","title":"ParameterType  <code>instance-attribute</code>","text":"<pre><code>ParameterType: int\n</code></pre> <p>Type of the parameter. Usually just 0 or 1.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SlotConnection.SlotType","title":"SlotType  <code>instance-attribute</code>","text":"<pre><code>SlotType: int\n</code></pre> <p>Type identifier for the slot.  Likely a bit flag enum.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SlotConnectionsWrapper","title":"SlotConnectionsWrapper","text":"<p>Wrapper for slot connections.</p> <p>Attributes:</p> <ul> <li> <code>SlotConnections</code>               (<code>dict[str, SlotConnection]</code>)           \u2013            <p>Dictionary mapping slot names (Slot0, Slot1, etc.) to connections.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.SlotConnectionsWrapper.SlotConnections","title":"SlotConnections  <code>instance-attribute</code>","text":"<pre><code>SlotConnections: dict[str, SlotConnection]\n</code></pre> <p>Dictionary mapping slot names (Slot0, Slot1, etc.) to connections.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task","title":"Task","text":"<p>JOBS workflow task structure.</p> <p>All JOBS tasks share this common structure. The Data and Parameters fields contain nested structures that vary based on the task configuration, but follow generic patterns (dicts with keys like 'CLxJobTask_*', 'Settings', 'CaptureLambda', etc.).</p> <p>The Name field is a user-provided label for the task, not a type indicator. Task dict keys in the Tasks dict are also user-provided identifiers.</p> <p>Attributes:</p> <ul> <li> <code>BlockNumber</code>               (<code>int</code>)           \u2013            <p>Block number for task grouping.</p> </li> <li> <code>Data</code>               (<code>dict[str, DataDictUnion | dict] | list[Any]</code>)           \u2013            <p>Task-specific data structure (varies by task configuration).</p> </li> <li> <code>JobtaskKeyRef</code>               (<code>int</code>)           \u2013            <p>Reference to parent task key (0 if none).</p> </li> <li> <code>Key</code>               (<code>int</code>)           \u2013            <p>Unique key identifying this task within the job.</p> </li> <li> <code>LockableParams</code>               (<code>LockableParamsWrapper</code>)           \u2013            <p>Parameters that can be locked/unlocked.</p> </li> <li> <code>Name</code>               (<code>str</code>)           \u2013            <p>User-provided label for this task.</p> </li> <li> <code>Notes</code>               (<code>str</code>)           \u2013            <p>User notes for this task.</p> </li> <li> <code>NotesDetailed</code>               (<code>str</code>)           \u2013            <p>Detailed description of what this task does.</p> </li> <li> <code>Order</code>               (<code>int</code>)           \u2013            <p>Execution order within the block.</p> </li> <li> <code>Parameters</code>               (<code>ParametersWrapper</code>)           \u2013            <p>Task-specific parameters.</p> </li> <li> <code>SlotConnections</code>               (<code>SlotConnectionsWrapper | list[Any]</code>)           \u2013            <p>Connections to other tasks' outputs.</p> </li> <li> <code>StateFlags</code>               (<code>int</code>)           \u2013            <p>State flags for the task.</p> </li> <li> <code>Version</code>               (<code>int</code>)           \u2013            <p>Task version number.</p> </li> </ul>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.BlockNumber","title":"BlockNumber  <code>instance-attribute</code>","text":"<pre><code>BlockNumber: int\n</code></pre> <p>Block number for task grouping.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Data","title":"Data  <code>instance-attribute</code>","text":"<pre><code>Data: dict[str, DataDictUnion | dict] | list[Any]\n</code></pre> <p>Task-specific data structure (varies by task configuration).</p> <p>Generally, the dict will have a single top-level key like 'CLxJobTask_*', 'Settings', 'CaptureLambda', etc., whose value is another dict or list containing the actual task configuration.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.JobtaskKeyRef","title":"JobtaskKeyRef  <code>instance-attribute</code>","text":"<pre><code>JobtaskKeyRef: int\n</code></pre> <p>Reference to parent task key (0 if none).</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Key","title":"Key  <code>instance-attribute</code>","text":"<pre><code>Key: int\n</code></pre> <p>Unique key identifying this task within the job.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.LockableParams","title":"LockableParams  <code>instance-attribute</code>","text":"<pre><code>LockableParams: LockableParamsWrapper\n</code></pre> <p>Parameters that can be locked/unlocked.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Name","title":"Name  <code>instance-attribute</code>","text":"<pre><code>Name: str\n</code></pre> <p>User-provided label for this task.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Notes","title":"Notes  <code>instance-attribute</code>","text":"<pre><code>Notes: str\n</code></pre> <p>User notes for this task.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.NotesDetailed","title":"NotesDetailed  <code>instance-attribute</code>","text":"<pre><code>NotesDetailed: str\n</code></pre> <p>Detailed description of what this task does.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Order","title":"Order  <code>instance-attribute</code>","text":"<pre><code>Order: int\n</code></pre> <p>Execution order within the block.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Parameters","title":"Parameters  <code>instance-attribute</code>","text":"<pre><code>Parameters: ParametersWrapper\n</code></pre> <p>Task-specific parameters.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.SlotConnections","title":"SlotConnections  <code>instance-attribute</code>","text":"<pre><code>SlotConnections: SlotConnectionsWrapper | list[Any]\n</code></pre> <p>Connections to other tasks' outputs.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.StateFlags","title":"StateFlags  <code>instance-attribute</code>","text":"<pre><code>StateFlags: int\n</code></pre> <p>State flags for the task.</p>"},{"location":"reference/nd2/jobs/types/#nd2.jobs.types.Task.Version","title":"Version  <code>instance-attribute</code>","text":"<pre><code>Version: int\n</code></pre> <p>Task version number.</p>"},{"location":"reference/nd2/structures/","title":"structures","text":""},{"location":"reference/nd2/structures/#nd2.structures","title":"nd2.structures","text":"<p>Dataclasses and other structures used for metadata.</p> <p>Classes:</p> <ul> <li> <code>AnimParam</code>           \u2013            <p>Parameters of ROI position/shape.</p> </li> <li> <code>Attributes</code>           \u2013            <p>Primary attributes of an ND2 file.</p> </li> <li> <code>BoxShape</code>           \u2013            <p>Size of a 3D box.</p> </li> <li> <code>Channel</code>           \u2013            <p>Structure of a channel in an ND2 file.</p> </li> <li> <code>ChannelMeta</code>           \u2013            <p>Metadata for a channel in an ND2 file.</p> </li> <li> <code>Color</code>           \u2013            <p>RGB color with optional alpha channel.</p> </li> <li> <code>Contents</code>           \u2013            <p>Contents of an ND2 file metadata.</p> </li> <li> <code>CustomLoop</code>           \u2013            <p>Custom loop in an experiment.</p> </li> <li> <code>ExperimentEvent</code>           \u2013            <p>An event in an experiment.</p> </li> <li> <code>ExtrudedShape</code>           \u2013            <p>Shape of an extruded object.</p> </li> <li> <code>FrameChannel</code>           \u2013            <p>Channel metadata for a frame.</p> </li> <li> <code>FrameMetadata</code>           \u2013            <p>Metadata of a frame in an ND2 file.</p> </li> <li> <code>InterpType</code>           \u2013            <p>The role that the ROI plays.</p> </li> <li> <code>LoopIndices</code>           \u2013            <p>Indices of loops in an channel.</p> </li> <li> <code>LoopType</code>           \u2013            <p>Type of loop in an experiment.</p> </li> <li> <code>Metadata</code>           \u2013            <p>Metadata of an ND2 file.</p> </li> <li> <code>Microscope</code>           \u2013            <p>Microscope metadata.</p> </li> <li> <code>NETimeLoop</code>           \u2013            <p>The time dimension of an nD experiment.</p> </li> <li> <code>NETimeLoopParams</code>           \u2013            <p>Parameters associated with a time loop in an nD experiment.</p> </li> <li> <code>Period</code>           \u2013            <p>A phase in an nD experiment.</p> </li> <li> <code>PeriodDiff</code>           \u2013            <p>Time difference between periods in a time loop.</p> </li> <li> <code>Position</code>           \u2013            <p>A position in an XY position loop.</p> </li> <li> <code>ROI</code>           \u2013            <p>ROI object from NIS Elements.</p> </li> <li> <code>RoiInfo</code>           \u2013            <p>Info associated with an ROI.</p> </li> <li> <code>RoiShapeType</code>           \u2013            <p>The type of ROI shape.</p> </li> <li> <code>ScopeType</code>           \u2013            <p>Scope of an ROI.</p> </li> <li> <code>StagePosition</code>           \u2013            <p>A position in stage coordinates.</p> </li> <li> <code>StimulationEvent</code>           \u2013            <p>Stimulation parameters for an experiment event.</p> </li> <li> <code>TextInfo</code>           \u2013            <p>Structure of <code>dict</code> returned by <code>ND2File.text_info</code>.</p> </li> <li> <code>TimeLoop</code>           \u2013            <p>The time dimension of an experiment.</p> </li> <li> <code>TimeLoopParams</code>           \u2013            <p>Parameters associated with a time loop.</p> </li> <li> <code>TimeStamp</code>           \u2013            <p>Absolute and relative timestamp of a frame.</p> </li> <li> <code>Volume</code>           \u2013            <p>Volume metadata.</p> </li> <li> <code>XYPoint</code>           \u2013            <p>XY coordinate.</p> </li> <li> <code>XYPosLoop</code>           \u2013            <p>A loop over XY positions in an experiment.</p> </li> <li> <code>XYPosLoopParams</code>           \u2013            <p>Parameters associated with a XY position loop.</p> </li> <li> <code>XYZPoint</code>           \u2013            <p>XYZ coordinate.</p> </li> <li> <code>ZStackLoop</code>           \u2013            <p>A loop over Z positions in an experiment.</p> </li> <li> <code>ZStackLoopParams</code>           \u2013            <p>Parameters associated with a Z stack loop.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>ExpLoop</code>           \u2013            <p>Union of loop types in an experiment.</p> </li> <li> <code>LoopParams</code>           \u2013            <p>Type of parameters associated with a loop in an experiment.</p> </li> <li> <code>ModalityFlags</code>           \u2013            <p>Flags indicating the modality of a microscope.</p> </li> </ul>"},{"location":"reference/nd2/structures/#nd2.structures.ExpLoop","title":"ExpLoop  <code>module-attribute</code>","text":"<pre><code>ExpLoop = Union[\n    TimeLoop, NETimeLoop, XYPosLoop, ZStackLoop, CustomLoop\n]\n</code></pre> <p>Union of loop types in an experiment.</p> <p><code>ND2File.experiment</code> returns a list of these.</p>"},{"location":"reference/nd2/structures/#nd2.structures.LoopParams","title":"LoopParams  <code>module-attribute</code>","text":"<pre><code>LoopParams = Union[\n    TimeLoopParams,\n    NETimeLoopParams,\n    XYPosLoopParams,\n    ZStackLoopParams,\n]\n</code></pre> <p>Type of parameters associated with a loop in an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ModalityFlags","title":"ModalityFlags  <code>module-attribute</code>","text":"<pre><code>ModalityFlags = Literal[\n    \"aux\",\n    \"brightfield\",\n    \"camera\",\n    \"diContrast\",\n    \"dsdConfocal\",\n    \"fluorescence\",\n    \"gaasp\",\n    \"iSIM\",\n    \"laserScanConfocal\",\n    \"liveSR\",\n    \"multiphoton\",\n    \"nonDescannedDetector\",\n    \"phaseContrast\",\n    \"pmt\",\n    \"RCM\",\n    \"remainder\",\n    \"SIM\",\n    \"sora\",\n    \"spectral\",\n    \"spinningDiskConfocal\",\n    \"sweptFieldConfocalPinhole\",\n    \"sweptFieldConfocalSlit\",\n    \"TIRF\",\n    \"transmitDetector\",\n    \"vaasIF\",\n    \"vaasNF\",\n    \"VCS\",\n    \"virtualFilter\",\n]\n</code></pre> <p>Flags indicating the modality of a microscope.</p>"},{"location":"reference/nd2/structures/#nd2.structures.AnimParam","title":"AnimParam  <code>dataclass</code>","text":"<pre><code>AnimParam(\n    timeMs: float = 0,\n    enabled: bool = True,\n    centerX: float = 0,\n    centerY: float = 0,\n    centerZ: float = 0,\n    rotationZ: float = 0,\n    boxShape: BoxShape = BoxShape(),\n    extrudedShape: ExtrudedShape = ExtrudedShape(),\n)\n</code></pre> <p>Parameters of ROI position/shape.</p> <p>Attributes:</p> <ul> <li> <code>center</code>               (<code>XYZPoint</code>)           \u2013            <p>Center point as a named tuple (x, y, z).</p> </li> </ul>"},{"location":"reference/nd2/structures/#nd2.structures.AnimParam.center","title":"center  <code>property</code>","text":"<pre><code>center: XYZPoint\n</code></pre> <p>Center point as a named tuple (x, y, z).</p>"},{"location":"reference/nd2/structures/#nd2.structures.Attributes","title":"Attributes","text":"<p>Primary attributes of an ND2 file.</p> <p>This is the return value of <code>ND2File.attributes</code>.</p>"},{"location":"reference/nd2/structures/#nd2.structures.BoxShape","title":"BoxShape","text":"<p>Size of a 3D box.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Channel","title":"Channel  <code>dataclass</code>","text":"<pre><code>Channel(\n    channel: ChannelMeta,\n    loops: LoopIndices | None,\n    microscope: Microscope,\n    volume: Volume,\n)\n</code></pre> <p>Structure of a channel in an ND2 file.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ChannelMeta","title":"ChannelMeta  <code>dataclass</code>","text":"<pre><code>ChannelMeta(\n    name: str,\n    index: int,\n    color: Color,\n    emissionLambdaNm: float | None = None,\n    excitationLambdaNm: float | None = None,\n)\n</code></pre> <p>Metadata for a channel in an ND2 file.</p> <p>Attributes:</p> <ul> <li> <code>colorRGBA</code>               (<code>int</code>)           \u2013            <p>Return color as unsigned 4-byte (32-bit) integer in ABGR format.</p> </li> </ul>"},{"location":"reference/nd2/structures/#nd2.structures.ChannelMeta.colorRGBA","title":"colorRGBA  <code>property</code>","text":"<pre><code>colorRGBA: int\n</code></pre> <p>Return color as unsigned 4-byte (32-bit) integer in ABGR format.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Color","title":"Color","text":"<p>RGB color with optional alpha channel.</p> <p>Methods:</p> <ul> <li> <code>as_abgr_u4</code>             \u2013              <p>Return color as an unsigned 4-byte (32-bit) integer in ABGR format.</p> </li> <li> <code>as_hex</code>             \u2013              <p>Return color as a hex string.</p> </li> <li> <code>from_abgr_u4</code>             \u2013              <p>Create a color from an unsigned 4-byte (32-bit) integer in ABGR format.</p> </li> </ul>"},{"location":"reference/nd2/structures/#nd2.structures.Color.as_abgr_u4","title":"as_abgr_u4","text":"<pre><code>as_abgr_u4() -&gt; int\n</code></pre> <p>Return color as an unsigned 4-byte (32-bit) integer in ABGR format.</p> <p>This is the native format of NIS Elements.</p> Source code in <code>src/nd2/structures.py</code> <pre><code>def as_abgr_u4(self) -&gt; int:\n    \"\"\"Return color as an unsigned 4-byte (32-bit) integer in ABGR format.\n\n    This is the native format of NIS Elements.\n    \"\"\"\n    # for the sake of round-tripping, we'll assume that 1.0 alpha is 0\n    alpha = 0 if self.a == 1.0 else int(self.a * 255)\n    return (alpha &lt;&lt; 24) + (self.b &lt;&lt; 16) + (self.g &lt;&lt; 8) + self.r\n</code></pre>"},{"location":"reference/nd2/structures/#nd2.structures.Color.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return color as a hex string.</p> Source code in <code>src/nd2/structures.py</code> <pre><code>def as_hex(self) -&gt; str:  # pragma: no cover\n    \"\"\"Return color as a hex string.\"\"\"\n    return f\"#{self.r:02x}{self.g:02x}{self.b:02x}\"\n</code></pre>"},{"location":"reference/nd2/structures/#nd2.structures.Color.from_abgr_u4","title":"from_abgr_u4  <code>classmethod</code>","text":"<pre><code>from_abgr_u4(val: int) -&gt; Color\n</code></pre> <p>Create a color from an unsigned 4-byte (32-bit) integer in ABGR format.</p> Source code in <code>src/nd2/structures.py</code> <pre><code>@classmethod\ndef from_abgr_u4(cls, val: int) -&gt; Color:\n    \"\"\"Create a color from an unsigned 4-byte (32-bit) integer in ABGR format.\"\"\"\n    return cls(\n        r=val &amp; 255,\n        g=val &gt;&gt; 8 &amp; 255,\n        b=val &gt;&gt; 16 &amp; 255,\n        # it's not clear if the alpha channel is used in NIS Elements\n        # so we default to 1.0 if it comes in as 0\n        a=((val &gt;&gt; 24 &amp; 255) / 255) or 1.0,\n    )\n</code></pre>"},{"location":"reference/nd2/structures/#nd2.structures.Contents","title":"Contents  <code>dataclass</code>","text":"<pre><code>Contents(channelCount: int, frameCount: int)\n</code></pre> <p>Contents of an ND2 file metadata.</p>"},{"location":"reference/nd2/structures/#nd2.structures.CustomLoop","title":"CustomLoop  <code>dataclass</code>","text":"<pre><code>CustomLoop(\n    count: int,\n    nestingLevel: int = 0,\n    parameters: None = None,\n    type: Literal[\"CustomLoop\"] = \"CustomLoop\",\n)\n</code></pre> <p>Custom loop in an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ExperimentEvent","title":"ExperimentEvent  <code>dataclass</code>","text":"<pre><code>ExperimentEvent(\n    id: int = 0,\n    time: float = 0.0,\n    time2: float = 0.0,\n    meaning: EventMeaning = Unspecified,\n    description: str = \"\",\n    data: str = \"\",\n    stimulation: StimulationEvent | None = None,\n)\n</code></pre> <p>An event in an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ExtrudedShape","title":"ExtrudedShape","text":"<p>Shape of an extruded object.</p>"},{"location":"reference/nd2/structures/#nd2.structures.FrameChannel","title":"FrameChannel  <code>dataclass</code>","text":"<pre><code>FrameChannel(\n    channel: ChannelMeta,\n    loops: LoopIndices | None,\n    microscope: Microscope,\n    volume: Volume,\n    position: Position,\n    time: TimeStamp,\n)\n</code></pre> <p>Channel metadata for a frame.</p>"},{"location":"reference/nd2/structures/#nd2.structures.FrameMetadata","title":"FrameMetadata  <code>dataclass</code>","text":"<pre><code>FrameMetadata(\n    contents: Contents, channels: list[FrameChannel]\n)\n</code></pre> <p>Metadata of a frame in an ND2 file.</p> <p>This is the return value of <code>ND2File.frame_metadata</code>.</p>"},{"location":"reference/nd2/structures/#nd2.structures.InterpType","title":"InterpType","text":"<p>The role that the ROI plays.</p>"},{"location":"reference/nd2/structures/#nd2.structures.LoopIndices","title":"LoopIndices  <code>dataclass</code>","text":"<pre><code>LoopIndices(\n    NETimeLoop: int | None = None,\n    TimeLoop: int | None = None,\n    XYPosLoop: int | None = None,\n    ZStackLoop: int | None = None,\n    CustomLoop: int | None = None,\n)\n</code></pre> <p>Indices of loops in an channel.</p>"},{"location":"reference/nd2/structures/#nd2.structures.LoopType","title":"LoopType","text":"<p>Type of loop in an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Metadata","title":"Metadata  <code>dataclass</code>","text":"<pre><code>Metadata(\n    contents: Contents | None = None,\n    channels: list[Channel] | None = None,\n)\n</code></pre> <p>Metadata of an ND2 file.</p> <p>This is the return value of <code>ND2File.metadata</code>.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Microscope","title":"Microscope  <code>dataclass</code>","text":"<pre><code>Microscope(\n    objectiveMagnification: float | None = None,\n    objectiveName: str | None = None,\n    objectiveNumericalAperture: float | None = None,\n    zoomMagnification: float | None = None,\n    immersionRefractiveIndex: float | None = None,\n    projectiveMagnification: float | None = None,\n    pinholeDiameterUm: float | None = None,\n    modalityFlags: list[ModalityFlags] = list(),\n)\n</code></pre> <p>Microscope metadata.</p>"},{"location":"reference/nd2/structures/#nd2.structures.NETimeLoop","title":"NETimeLoop  <code>dataclass</code>","text":"<pre><code>NETimeLoop(\n    count: int,\n    nestingLevel: int,\n    parameters: NETimeLoopParams,\n    type: Literal[\"NETimeLoop\"] = \"NETimeLoop\",\n)\n</code></pre> <p>The time dimension of an nD experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.NETimeLoopParams","title":"NETimeLoopParams  <code>dataclass</code>","text":"<pre><code>NETimeLoopParams(periods: list[Period])\n</code></pre> <p>Parameters associated with a time loop in an nD experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Period","title":"Period  <code>dataclass</code>","text":"<pre><code>Period(\n    startMs: float,\n    periodMs: float,\n    durationMs: float,\n    periodDiff: PeriodDiff,\n    count: int,\n)\n</code></pre> <p>A phase in an nD experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.PeriodDiff","title":"PeriodDiff  <code>dataclass</code>","text":"<pre><code>PeriodDiff(avg: float = 0, max: float = 0, min: float = 0)\n</code></pre> <p>Time difference between periods in a time loop.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Position","title":"Position  <code>dataclass</code>","text":"<pre><code>Position(\n    stagePositionUm: StagePosition,\n    pfsOffset: float | None = None,\n    name: str | None = None,\n)\n</code></pre> <p>A position in an XY position loop.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ROI","title":"ROI  <code>dataclass</code>","text":"<pre><code>ROI(\n    id: int,\n    info: RoiInfo,\n    guid: str,\n    animParams: list[AnimParam] = list(),\n)\n</code></pre> <p>ROI object from NIS Elements.</p>"},{"location":"reference/nd2/structures/#nd2.structures.RoiInfo","title":"RoiInfo  <code>dataclass</code>","text":"<pre><code>RoiInfo(\n    shapeType: RoiShapeType,\n    interpType: InterpType,\n    cookie: int = 0,\n    color: int = 255,\n    label: str = \"\",\n    stimulationGroup: int = 0,\n    scope: ScopeType = Global,\n    appData: int = 0,\n    multiFrame: bool = False,\n    locked: bool = False,\n    compCount: int = 2,\n    bpc: int = 16,\n    autodetected: bool = False,\n    gradientStimulation: bool = False,\n    gradientStimulationBitDepth: int = 0,\n    gradientStimulationLo: float = 0.0,\n    gradientStimulationHi: float = 0.0,\n)\n</code></pre> <p>Info associated with an ROI.</p>"},{"location":"reference/nd2/structures/#nd2.structures.RoiShapeType","title":"RoiShapeType","text":"<p>The type of ROI shape.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ScopeType","title":"ScopeType","text":"<p>Scope of an ROI.</p>"},{"location":"reference/nd2/structures/#nd2.structures.StagePosition","title":"StagePosition","text":"<p>A position in stage coordinates.</p>"},{"location":"reference/nd2/structures/#nd2.structures.StimulationEvent","title":"StimulationEvent  <code>dataclass</code>","text":"<pre><code>StimulationEvent(\n    type: StimulationType = NoStimulation,\n    loop_index: int = 0,\n    position: int = 0,\n    description: str = \"\",\n)\n</code></pre> <p>Stimulation parameters for an experiment event.</p>"},{"location":"reference/nd2/structures/#nd2.structures.TextInfo","title":"TextInfo","text":"<p>Structure of <code>dict</code> returned by <code>ND2File.text_info</code>.</p>"},{"location":"reference/nd2/structures/#nd2.structures.TimeLoop","title":"TimeLoop  <code>dataclass</code>","text":"<pre><code>TimeLoop(\n    count: int,\n    nestingLevel: int,\n    parameters: TimeLoopParams,\n    type: Literal[\"TimeLoop\"] = \"TimeLoop\",\n)\n</code></pre> <p>The time dimension of an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.TimeLoopParams","title":"TimeLoopParams  <code>dataclass</code>","text":"<pre><code>TimeLoopParams(\n    startMs: float,\n    periodMs: float,\n    durationMs: float,\n    periodDiff: PeriodDiff,\n)\n</code></pre> <p>Parameters associated with a time loop.</p>"},{"location":"reference/nd2/structures/#nd2.structures.TimeStamp","title":"TimeStamp  <code>dataclass</code>","text":"<pre><code>TimeStamp(\n    absoluteJulianDayNumber: float, relativeTimeMs: float\n)\n</code></pre> <p>Absolute and relative timestamp of a frame.</p>"},{"location":"reference/nd2/structures/#nd2.structures.Volume","title":"Volume  <code>dataclass</code>","text":"<pre><code>Volume(\n    axesCalibrated: tuple[bool, bool, bool],\n    axesCalibration: tuple[float, float, float],\n    axesInterpretation: tuple[\n        AxisInterpretation,\n        AxisInterpretation,\n        AxisInterpretation,\n    ],\n    bitsPerComponentInMemory: int,\n    bitsPerComponentSignificant: int,\n    cameraTransformationMatrix: tuple[\n        float, float, float, float\n    ],\n    componentCount: int,\n    componentDataType: Literal[\"unsigned\", \"float\"],\n    voxelCount: tuple[int, int, int],\n    componentMaxima: list[float] | None = None,\n    componentMinima: list[float] | None = None,\n    pixelToStageTransformationMatrix: tuple[\n        float, float, float, float, float, float\n    ]\n    | None = None,\n)\n</code></pre> <p>Volume metadata.</p>"},{"location":"reference/nd2/structures/#nd2.structures.XYPoint","title":"XYPoint","text":"<p>XY coordinate.</p>"},{"location":"reference/nd2/structures/#nd2.structures.XYPosLoop","title":"XYPosLoop  <code>dataclass</code>","text":"<pre><code>XYPosLoop(\n    count: int,\n    nestingLevel: int,\n    parameters: XYPosLoopParams,\n    type: Literal[\"XYPosLoop\"] = \"XYPosLoop\",\n)\n</code></pre> <p>A loop over XY positions in an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.XYPosLoopParams","title":"XYPosLoopParams  <code>dataclass</code>","text":"<pre><code>XYPosLoopParams(isSettingZ: bool, points: list[Position])\n</code></pre> <p>Parameters associated with a XY position loop.</p>"},{"location":"reference/nd2/structures/#nd2.structures.XYZPoint","title":"XYZPoint","text":"<p>XYZ coordinate.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ZStackLoop","title":"ZStackLoop  <code>dataclass</code>","text":"<pre><code>ZStackLoop(\n    count: int,\n    nestingLevel: int,\n    parameters: ZStackLoopParams,\n    type: Literal[\"ZStackLoop\"] = \"ZStackLoop\",\n)\n</code></pre> <p>A loop over Z positions in an experiment.</p>"},{"location":"reference/nd2/structures/#nd2.structures.ZStackLoopParams","title":"ZStackLoopParams  <code>dataclass</code>","text":"<pre><code>ZStackLoopParams(\n    homeIndex: int,\n    stepUm: float,\n    bottomToTop: bool,\n    deviceName: str | None = None,\n)\n</code></pre> <p>Parameters associated with a Z stack loop.</p>"},{"location":"reference/nd2/tiff/","title":"tiff","text":""},{"location":"reference/nd2/tiff/#nd2.tiff","title":"nd2.tiff","text":"<p>Functions for converting .nd2 to .tiff files.</p> <p>Functions:</p> <ul> <li> <code>nd2_to_tiff</code>             \u2013              <p>Export an ND2 file to an (OME)-TIFF file.</p> </li> </ul>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff","title":"nd2_to_tiff","text":"<pre><code>nd2_to_tiff(\n    source: str | PathLike | ND2File,\n    dest: str | PathLike,\n    *,\n    include_unstructured_metadata: bool = True,\n    progress: bool = False,\n    on_frame: Callable[[int, int, dict[str, int]], None]\n    | None = None,\n    modify_ome: Callable[[OME], None] | None = None,\n) -&gt; None\n</code></pre> <p>Export an ND2 file to an (OME)-TIFF file.</p> <p>To include OME-XML metadata, use extension <code>.ome.tif</code> or <code>.ome.tiff</code>.</p> <p>https://docs.openmicroscopy.org/ome-model/6.3.1/ome-tiff/specification.html</p> <p>Parameters:</p> Source code in <code>src/nd2/tiff.py</code> <pre><code>def nd2_to_tiff(\n    source: str | PathLike | ND2File,\n    dest: str | PathLike,\n    *,\n    include_unstructured_metadata: bool = True,\n    progress: bool = False,\n    on_frame: Callable[[int, int, dict[str, int]], None] | None = None,\n    modify_ome: Callable[[ome_types.OME], None] | None = None,\n) -&gt; None:\n    \"\"\"Export an ND2 file to an (OME)-TIFF file.\n\n    To include OME-XML metadata, use extension `.ome.tif` or `.ome.tiff`.\n\n    &lt;https://docs.openmicroscopy.org/ome-model/6.3.1/ome-tiff/specification.html&gt;\n\n    Parameters\n    ----------\n    source : str | PathLike | ND2File\n        The ND2 file path or an open ND2File object.\n    dest : str  | PathLike\n        The destination TIFF file.\n    include_unstructured_metadata :  bool\n        Whether to include unstructured metadata in the OME-XML. This includes all of\n        the metadata that we can find in the ND2 file in the StructuredAnnotations\n        section of the OME-XML (as mapping of metadata chunk name to JSON-encoded\n        string). By default `True`.\n    progress : bool\n        Whether to display progress bar.  If `True` and `tqdm` is installed, it will\n        be used. Otherwise, a simple text counter will be printed to the console.\n        By default `False`.\n    on_frame : Callable[[int, int, dict[str, int]], None] | None\n        A function to call after each frame is written. The function should accept\n        three arguments: the current frame number, the total number of frames, and\n        a dictionary of the current frame's indices (e.g. `{\"T\": 0, \"Z\": 1}`)\n        (Useful for integrating custom progress bars or logging.)\n    modify_ome : Callable[[ome_types.OME], None]\n        A function to modify the OME metadata before writing it to the file.\n        Accepts an `ome_types.OME` object and should modify it in place.\n        (reminder: OME-XML is only written if the file extension is `.ome.tif` or\n        `.ome.tiff`)\n    \"\"\"\n    dest_path = Path(dest).expanduser().resolve()\n    output_ome = \".ome.\" in dest_path.name\n\n    # normalize source to an open ND2File, and remember if we opened it\n    close_when_done = False\n    if isinstance(source, (str, PathLike)):\n        from ._nd2file import ND2File\n\n        nd2f = ND2File(source)\n        close_when_done = True\n    else:\n        nd2f = source\n        if close_when_done := nd2f.closed:\n            nd2f.open()\n\n    try:\n        # map of axis_name -&gt; size\n        sizes = dict(nd2f.sizes)\n\n        # pop the number of positions from the sizes.\n        # The OME data model does best with 5D data, so we'll write multi-5D series\n        n_positions = sizes.pop(AXIS.POSITION, 1)\n\n        # join axis names as a string, and get shape of the data without positions\n        axes, shape = zip(*sizes.items())\n        # U (Unknown) -&gt; Q : other (OME)\n        metadata = {\"axes\": \"\".join(axes).upper().replace(AXIS.UNKNOWN, \"Q\")}\n\n        # Create OME-XML\n        ome_xml: bytes | None = None\n        if output_ome:\n            if nd2f.is_legacy:\n                warnings.warn(\n                    \"Cannot write OME metadata for legacy nd2 files.\"\n                    \"Please use a different file extension to avoid confusion\",\n                    stacklevel=2,\n                )\n            else:\n                # get the OME metadata object from the ND2File\n                ome = nd2_ome_metadata(\n                    nd2f,\n                    include_unstructured=include_unstructured_metadata,\n                    tiff_file_name=dest_path.name,\n                )\n                if modify_ome:\n                    # allow user to modify the OME metadata if they want\n                    modify_ome(ome)\n                ome_xml = ome.to_xml(exclude_unset=True).encode(\"utf-8\")\n\n        # total number of frames we will write\n        tot = nd2f._frame_count\n        # create a progress bar if requested\n        pbar = _pbar(total=tot, desc=f\"Exporting {nd2f.path}\") if progress else None\n\n        # `p_groups` will be a map of {position index -&gt; [(frame_number, f_index) ...]}\n        # where frame_number is passed to read_frame\n        # and f_index is a map of axis name to index (e.g. {\"T\": 0, \"Z\": 1})\n        # positions are grouped together so we can write them to the tiff file in order\n        p_groups: defaultdict[int, list[tuple[int, dict[str, int]]]] = defaultdict(list)\n        for f_num, f_index in enumerate(nd2f.loop_indices):\n            p_groups[f_index.get(AXIS.POSITION, 0)].append((f_num, f_index))\n\n        # create a function to iterate over all frames, updating pbar if requested\n        def position_iter(p: int) -&gt; Iterator[np.ndarray]:\n            \"\"\"Iterator over frames for a given position.\"\"\"\n            for f_num, f_index in p_groups[p]:\n                # call on_frame callback if provided\n                if on_frame is not None:\n                    on_frame(f_num, tot, f_index)\n\n                # yield the frame and update the progress bar\n                yield nd2f.read_frame(f_num)\n                if pbar is not None:\n                    pbar.set_description(repr(f_index))\n                    pbar.update()\n\n        # if we have ome_xml, we tell tifffile not to worry about it (ome=False)\n        tf_ome = False if ome_xml else None\n        # Write the tiff file\n        pixelsize = nd2f.voxel_size().x\n        photometric = tf.PHOTOMETRIC.RGB if nd2f.is_rgb else tf.PHOTOMETRIC.MINISBLACK\n        with tf.TiffWriter(dest_path, bigtiff=True, ome=tf_ome) as tif:\n            for p in range(n_positions):\n                tif.write(\n                    iter(position_iter(p)),\n                    shape=shape,\n                    dtype=nd2f.dtype,\n                    resolution=(1 / pixelsize, 1 / pixelsize),\n                    resolutionunit=tf.RESUNIT.MICROMETER,\n                    photometric=photometric,\n                    metadata=metadata,\n                    description=ome_xml,\n                )\n\n        if pbar is not None:\n            pbar.close()\n\n    finally:\n        # close the nd2 file if we opened it\n        if close_when_done:\n            nd2f.close()\n</code></pre>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff(source)","title":"<code>source</code>","text":"(<code>str | PathLike | ND2File</code>)           \u2013            <p>The ND2 file path or an open ND2File object.</p>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>The destination TIFF file.</p>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff(include_unstructured_metadata)","title":"<code>include_unstructured_metadata</code>","text":"(<code> bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include unstructured metadata in the OME-XML. This includes all of the metadata that we can find in the ND2 file in the StructuredAnnotations section of the OME-XML (as mapping of metadata chunk name to JSON-encoded string). By default <code>True</code>.</p>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display progress bar.  If <code>True</code> and <code>tqdm</code> is installed, it will be used. Otherwise, a simple text counter will be printed to the console. By default <code>False</code>.</p>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff(on_frame)","title":"<code>on_frame</code>","text":"(<code>Callable[[int, int, dict[str, int]], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>A function to call after each frame is written. The function should accept three arguments: the current frame number, the total number of frames, and a dictionary of the current frame's indices (e.g. <code>{\"T\": 0, \"Z\": 1}</code>) (Useful for integrating custom progress bars or logging.)</p>"},{"location":"reference/nd2/tiff/#nd2.tiff.nd2_to_tiff(modify_ome)","title":"<code>modify_ome</code>","text":"(<code>Callable[[OME], None]</code>, default:                   <code>None</code> )           \u2013            <p>A function to modify the OME metadata before writing it to the file. Accepts an <code>ome_types.OME</code> object and should modify it in place. (reminder: OME-XML is only written if the file extension is <code>.ome.tif</code> or <code>.ome.tiff</code>)</p>"}]}